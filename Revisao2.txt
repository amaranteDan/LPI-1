####################################################
Revis√£o da 103

https://learning.lpi.org/pt/learning-materials/101-500/103/103.1/103.1_01/

pwd -Onde estou

touch cria arquivo

uname -a ou --all

apropos <comando> Localiza onde √© possivel verificar informa√ß√µes do comando (Paginas do manual)

# type uname cp kill which
uname is hashed (/usr/bin/uname)
cp is /usr/bin/cp
kill is a shell builtin
which is hashed (/usr/bin/which)

history
bash_history / .bash_history Banco de dados dinamico do history

ls -la Mostra arquivos ocultos

env Verifica as variaveis de ambiente e seus valores

echo Exibe na tela
echo "How are you"

echo $PATH

***Criando minha variavel

myvar=hello
$myvar


bash - abre novo terminal 

***exportar variavel

export myvar

echo $myvar

***Removendo

unset myvar

*** set Exibe todas as variaveis e fun√ß√µes

# set | grep PATH
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    local PATH=$PATH:/sbin;
    if [[ -z ${CDPATH:-} || $cur == ?(.)?(.)/* ]]; then
    for i in ${CDPATH//:/'
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
    COMPREPLY=($(compgen -W "$(PATH="$PATH:/sbin" lsmod |
    local PATH=$PATH:/sbin;
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(compgen -W         "$(PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur"))
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    COMPREPLY+=($(compgen -W         "$(PATH="$PATH:/sbin" lsusb | awk '{print $6}')" -- "$cur"))
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$AWKLIBPATH:$*"
    unset AWKLIBPATH;
    export AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$*:$AWKLIBPATH"
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$AWKPATH:$*"
    unset AWKPATH;
    export AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$*:$AWKPATH"

diff - Verificando a diferen√ßa entre os arquivos

cat verifica o conteudo de u arquivo


zcat visualiza o conteudo de um gzip

bzcat le o conteudo do bzpi2

xzcat le o conteu do xz

gunzip para descompactar o gzip




less paginador 


less /var/log/messages

head le as primeiras 10 linhas de um arquivo

head /var/log/messages

tail - usado para ler as ultimas linhas de um arquivo

tail /var/log/messages


nl contador de linhas


head /var/log/messages |  nl

# head /var/log/messages | nl
     1  Apr 18 18:49:32 dublin rsyslogd: [origin software="rsyslogd" swVersion="8.2010.0" x-pid="497" x-info="https://www.rsyslog.com"] rsyslogd was HUPed
     2  Apr 18 18:49:35 dublin lightdm[811]: Error getting user list from org.freedesktop.Accounts: GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name org.freedesktop.Accounts was not provided by any .service files
     3  Apr 18 18:50:04 dublin lightdm[884]: Error getting user list from org.freedesktop.Accounts: GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name org.freedesktop.Accounts was not provided by any .service files
     4  Apr 18 18:50:13 dublin colord[1109]: failed to get edid data: EDID length is too small
     5  Apr 18 18:50:14 dublin org.freedesktop.thumbnails.Thumbnailer1[1088]: Registered thumbnailer /usr/bin/gdk-pixbuf-thumbnailer -s %s %u %o
     6  Apr 18 18:50:14 dublin org.freedesktop.thumbnails.Thumbnailer1[1088]: Registered thumbnailer /usr/bin/gdk-pixbuf-thumbnailer -s %s %u %o
     7  Apr 18 18:50:14 dublin org.freedesktop.thumbnails.Thumbnailer1[1088]: Registered thumbnailer atril-thumbnailer -s %s %u %o
     8  Apr 18 18:50:15 dublin udisksd[1166]: udisks daemon version 2.9.1 starting
     9  Apr 18 18:50:15 dublin udisksd[1166]: failed to load module mdraid: libbd_mdraid.so.2: cannot open shared object file: No such file or directory
    10  Apr 18 18:50:15 dublin udisksd[1166]: Failed to load the 'mdraid' libblockdev plugin

wc -Contador de caracteres 
	-l conta as linhas tambem


# tail /var/log/messages | wc -l
10

# tail -n 5 /var/log/messages
Apr 20 00:10:03 dublin rsyslogd: [origin software="rsyslogd" swVersion="8.2010.0" x-pid="497" x-info="https://www.rsyslog.com"] rsyslogd was HUPed
Apr 20 00:36:00 dublin lightdm[10932]: Error getting user list from org.freedesktop.Accounts: GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name org.freedesktop.Accounts was not provided by any .service files
Apr 20 09:37:14 dublin lightdm[13774]: Error getting user list from org.freedesktop.Accounts: GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name org.freedesktop.Accounts was not provided by any .service files
Apr 20 11:36:31 dublin lightdm[14413]: Error getting user list from org.freedesktop.Accounts: GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name org.freedesktop.Accounts was not provided by any .service files
Apr 20 11:40:31 dublin lightdm[14546]: Error getting user list from org.freedesktop.Accounts: GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name org.freedesktop.Accounts was not provided by any .service files

grep -v "root" faz a busca omitindo a palavra root

Sed - editor de fluxo

$ sed -n /cat/p < ftu.txt  sed -n para imprimi tudo na tela, a n√£o ser a saidas do comando p
bzcat
cat
xzcat
zcat  


# sed /cat/d < ftu.txt -Nesse caso o sed imprime na tela tudo exceto "cat" ou palavras que tenham cat. Ordenado pelo comando d 
cut
head
less
nl
od
paste
join
sed
sha256sum
sha512sum
sort
split
tail
tr
uniq
wc


# sed s/cat/dog/ < ftu.txt  -Nesse caso, o comando s vai substituir nas ocorrencias /cat por /dog e imprimir na tela. "Lembrete"- Isso n√£o altera o arquivo.
dog
bzdog
xzdog
zdog
dog
cut
head
less
nl
od
paste
join
sed
sha256sum
sha512sum
sort
split
tail
tr
uniq
wc

$ sed -i.backup s/cat/dog/ ftu.txt
$ ls ftu*
ftu.txt  ftu.txt.backup
A op√ß√£o -i executa uma opera√ß√£o sed local no arquivo original. Se voc√™ n√£o usar .backup ap√≥s o par√¢metro -i, vai reescrever o arquivo original. Qualquer texto inserido ap√≥s o par√¢metro -i ser√° o nome com o qual o arquivo original ser√° salvo antes das modifica√ß√µes que voc√™ pediu ao sed para realizar.


Garantindo a integridade dos dados
Como vimos, √© f√°cil manipular arquivos no Linux. H√° momentos em que queremos compartilhar um arquivo com outra pessoa e ter certeza de que o destinat√°rio receber√° uma c√≥pia fiel do arquivo original. Um uso muito comum dessa t√©cnica √© quando os servidores das distribui√ß√µes Linux hospedam imagens de CD ou DVD de seu software para download, juntamente com arquivos que cont√™m os valores calculados da soma de verifica√ß√£o (checksum) dessas imagens de disco.

Ex# sha256sum ftu.txt 
332a4bb3e6e415749c6553ec402d3926a59f42038beab8a759c8420ad1b45c0a  ftu.txt


# sha256sum ftu.txt > sha256.txt
‚îå‚îÄ‚îÄ(rootüíÄdublin)-[/etc]
‚îî‚îÄ# sha256sum -c sha256.txt 
ftu.txt: OK

# sha256sum -c sha256.txt 
ftu.txt: FAILED
sha256sum: WARNING: 1 computed checksum did NOT match  -Nesse caso houve a falha devido a adi√ß√£o de mais informa√ß√µes no arquivo ftu.txt

od - Comando Octal dump -Para depurar aplicativos e diversos tipos de arquivos

Listando o conteudo de um arquivo de forma octal
# od ftu.txt 
0000000 060543 005164 075142 060543 005164 075170 060543 005164
0000020 061572 072141 062012 063557 061412 072165 064012 060545
0000040 005144 062554 071563 067012 005154 062157 070012 071541
0000060 062564 065012 064557 005156 062563 005144 064163 031141
0000100 033065 072563 005155 064163 032541 031061 072563 005155
0000120 067563 072162 071412 066160 072151 072012 064541 005154
0000140 071164 072412 064556 005161 061567 005012 067556 060566
0000160 066040 067151 060550 000012
0000167

Listando o conteudo em formato hexadecimal
# od -x ftu.txt 
0000000 6163 0a74 7a62 6163 0a74 7a78 6163 0a74
0000020 637a 7461 640a 676f 630a 7475 680a 6165
0000040 0a64 656c 7373 6e0a 0a6c 646f 700a 7361
0000060 6574 6a0a 696f 0a6e 6573 0a64 6873 3261
0000100 3635 7573 0a6d 6873 3561 3231 7573 0a6d
0000120 6f73 7472 730a 6c70 7469 740a 6961 0a6c
0000140 7274 750a 696e 0a71 6377 0a0a 6f6e 6176
0000160 6c20 6e69 6168 000a
0000167

Depurando o arquivo por caracteres. A ocorrencias da linha que foi adicionada esta como \n

# od -c ftu.txt 
0000000   c   a   t  \n   b   z   c   a   t  \n   x   z   c   a   t  \n
0000020   z   c   a   t  \n   d   o   g  \n   c   u   t  \n   h   e   a
0000040   d  \n   l   e   s   s  \n   n   l  \n   o   d  \n   p   a   s
0000060   t   e  \n   j   o   i   n  \n   s   e   d  \n   s   h   a   2
0000100   5   6   s   u   m  \n   s   h   a   5   1   2   s   u   m  \n
0000120   s   o   r   t  \n   s   p   l   i   t  \n   t   a   i   l  \n
0000140   t   r  \n   u   n   i   q  \n   w   c  \n  \n   n   o   v   a
0000160       l   i   n   h   a  \n
0000167

*Verificando um arquivo sem o deslocamento do byte

od -An -c ftu.txt

# od -An -c ftu.txt 
   c   a   t  \n   b   z   c   a   t  \n   x   z   c   a   t  \n
   z   c   a   t  \n   d   o   g  \n   c   u   t  \n   h   e   a
   d  \n   l   e   s   s  \n   n   l  \n   o   d  \n   p   a   s
   t   e  \n   j   o   i   n  \n   s   e   d  \n   s   h   a   2
   5   6   s   u   m  \n   s   h   a   5   1   2   s   u   m  \n
   s   o   r   t  \n   s   p   l   i   t  \n   t   a   i   l  \n
   t   r  \n   u   n   i   q  \n   w   c  \n  \n   n   o   v   a
       l   i   n   h   a  \n


Algu√©m acaba de doar um laptop para sua escola e voc√™ deseja instalar Linux nele. Ele veio sem manual e voc√™ √© obrigado a inicializ√°-lo a partir de um pen drive USB sem nenhuma interface gr√°fica. Aparece um terminal shell e voc√™ sabe que, para cada processador presente, haver√° uma linha dedicada no arquivo /proc/cpuinfo:

processor	: 0
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(lines skipped)

processor	: 1
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(more lines skipped)
Usando os comandos grep e wc, exiba o n√∫mero de processadores presentes.

Eis duas op√ß√µes:

$ cat /proc/cpuinfo | grep processor | wc -l
$ grep processor /proc/cpuinfo | wc -l
Agora que voc√™ sabe que existem v√°rias maneiras de fazer a mesma coisa, quando deve usar uma ou outra? Isso depende de v√°rios fatores, sendo os dois mais importantes o desempenho e a legibilidade. Na maioria das vezes, usamos comandos de shell dentro de scripts de shell para automatizar tarefas; quanto maiores e mais complexos seus scripts se tornam, mais precisamos nos preocupar em mant√™-los r√°pidos.

Fa√ßa o mesmo com sed em vez de grep.

Agora, em vez de grep vamos tentar isso com sed:

$ sed -n /processor/p /proc/cpuinfo | wc -l
Aqui, usamos sed com o par√¢metro -n para que sed n√£o imprima nada, exceto o que corresponde √† express√£o processor, conforme instru√≠do pelo comando p . Como fizemos nas solu√ß√µes de grep, wc -l conta o n√∫mero de linhas e, portanto, o n√∫mero de processadores presentes.

Estude o exemplo a seguir:

$ sed -n /processor/p /proc/cpuinfo | sed -n '$='
Esta sequ√™ncia de comando fornece resultados id√™nticos aos do exemplo anterior, no qual a sa√≠da de sed foi canalizada para um comando wc. A diferen√ßa, aqui, √© que em vez de usar wc -l para contar o n√∫mero de linhas, sed √© novamente invocado para fornecer uma funcionalidade equivalente. Mais uma vez, estamos suprimindo a sa√≠da de sed com a op√ß√£o -n, exceto para a express√£o que estamos chamando explicitamente, que √© '$='. Essa express√£o diz ao sed para encontrar uma correspond√™ncia para a √∫ltima linha ($) e ent√£o imprimir o n√∫mero dessa linha (=).

Explore seu arquivo local /etc/passwd com os comandos grep, sed, head e tail de acordo com as tarefas descritas abaixo:

Quais usu√°rios t√™m acesso a um shell Bash?

$ grep ":/bin/bash$" /etc/passwd
Vamos refinar esta resposta exibindo apenas o nome do usu√°rio que utiliza o shell Bash.

$ grep ":/bin/bash$" /etc/passwd | cut -d: -f1
O nome do usu√°rio √© o primeiro campo (par√¢metro -f1 do comando cut) e o arquivo /etc/passwd usa : como separadores (-d: par√¢metro do comando cut). N√≥s apenas canalizamos a sa√≠da do comando grep para o comando cut apropriado.

Muitos dos usu√°rios de seu sistema existem para lidar com programas espec√≠ficos ou para fins administrativos. Eles n√£o t√™m acesso a um shell. Quantos deles est√£o presentes no sistema?

A maneira mais f√°cil de descobrir isso √© exibir as linhas correspondentes √†s contas que n√£o usam o shell Bash:

$ grep -v ":/bin/bash$" /etc/passwd | wc -l
Quantos usu√°rios e grupos existem em seu sistema (lembre-se: use apenas o arquivo /etc/passwd)?

O primeiro campo de qualquer linha do arquivo /etc/passwd √© o nome do usu√°rio, o segundo √© tipicamente um x indicando que a senha do usu√°rio n√£o est√° armazenada aqui (ela √© criptografada no arquivo /etc/shadow). O terceiro √© o id do usu√°rio (UID) e o quarto √© o id do grupo (GID). Portanto, isso deve nos fornecer o n√∫mero de usu√°rios:

$ cut -d: -f3 /etc/passwd | wc -l
Bem, isso funciona na maioria dos casos. No entanto, h√° situa√ß√µes em que definimos diferentes superusu√°rios ou outros tipos especiais de usu√°rios que compartilham o mesmo UID (id de usu√°rio). Assim, para ter certeza, vamos canalizar o resultado do comando cut para o comando sort e ent√£o contar o n√∫mero de linhas.

$ cut -d: -f3 /etc/passwd | sort -u | wc -l
Agora, para o n√∫mero de grupos:

$ cut -d: -f4 /etc/passwd | sort -u | wc -l
Liste apenas a primeira, a √∫ltima e a d√©cima linha do arquivo /etc/passwd.

Podemos fazer assim:

$ sed -n -e '1'p -e '10'p -e '$'p /etc/passwd
Lembre-se de que o par√¢metro -n diz ao sed para n√£o imprimir nada al√©m do que √© especificado pelo comando p. O cifr√£o ($) usado aqui √© uma express√£o regular que representa a √∫ltima linha do arquivo.

Considere este exemplo do arquivo /etc/passwd. Copie as linhas abaixo para um arquivo local chamado mypasswd para este exerc√≠cio.

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
nvidia-persistenced:x:121:128:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin
libvirt-qemu:x:64055:130:Libvirt Qemu,,,:/var/lib/libvirt:/usr/sbin/nologin
libvirt-dnsmasq:x:122:133:Libvirt Dnsmasq,,,:/var/lib/libvirt/dnsmasq:/usr/sbin/nologin
carol:x:1000:2000:Carol Smith,Human Resources,,,Main Office:/home/carol:/bin/bash
dave:x:1001:1000:Dave Edwards,Human Resources,,,Main Office:/home/dave:/bin/ksh
emma:x:1002:1000:Emma Jones,Human Resources,,,Main Office:/home/emma:/bin/bash
frank:x:1003:1000:Frank Cassidy,Human Resources,,,Main Office:/home/frank:/bin/bash
grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
henry:x:1005:1000:Henry Adams,Accounts Payable,,,Main Office:/home/henry:/bin/bash
john:x:1006:1000:John Chapel,Accounts Payable,,,Main Office:/home/john:/bin/bash
Liste todos os usu√°rios no grupo 1000 (use sed para selecionar apenas o campo apropriado) do arquivo mypasswd.

O GID √© o quarto campo do arquivo /etc/passwd. Voc√™ pode ter vontade de tentar o seguinte:

$ sed -n /1000/p mypasswd
Nesse caso, voc√™ obter√° tamb√©m esta linha:

carol:x:1000:2000:Carol Smith,Human Resources,,,Main Office:/home/carol:/bin/bash
Sabemos que n√£o est√° correto, pois Carol Smith √© membro do GID 2000 e a correspond√™ncia foi encontrada por causa do UID. No entanto, voc√™ deve ter notado que, ap√≥s o GID, o campo seguinte come√ßa com um caractere mai√∫sculo. Podemos usar uma express√£o regular para resolver esse problema.

$ sed -n /:1000:[A-Z]/p mypasswd
A express√£o [A-Z] busca por quaisquer caracteres em mai√∫sculas. Vamos falar mais sobre isso na li√ß√£o correspondente.

Liste apenas o nome completo de todos os usu√°rios deste grupo (use sed e cut).

Use a mesma t√©cnica empregada para resolver a primeira parte deste exerc√≠cio e canalize para um comando cut.

$ sed -n /:1000:[A-Z]/p mypasswd | cut -d: -f5
Dave Edwards,Human Resources,,,Main Office
Emma Jones,Human Resources,,,Main Office
Frank Cassidy,Human Resources,,,Main Office
Grace Kearns,Engineering,,,Main Office
Henry Adams,Accounts Payable,,,Main Office
John Chapel,Accounts Payable,,,Main Office
Ainda n√£o chegamos l√°! Note como os campos dentro dos resultados podem ser separados por ,. Assim, vamos canalizar a sa√≠da para outro comando cut, usando , como delimitador.

$ sed -n /:1000:[A-Z]/p mypasswd | cut -d: -f5 | cut -d, -f1
Dave Edwards
Emma Jones
Frank Cassidy
Grace Kearns
Henry Adams
John Chapel
Respostas aos Exerc√≠cios Explorat√≥rios
Usando novamente o arquivo mypasswd dos exerc√≠cios anteriores, imagine um comando Bash que selecione um indiv√≠duo do Main Office para ganhar uma rifa. Use o comando sed para imprimir apenas as linhas do Main Office e, em seguida, uma sequ√™ncia de comando cut para recuperar o primeiro nome de cada usu√°rio a partir dessas linhas. Depois, classifique esses nomes aleatoriamente e imprima apenas o nome principal da lista.

Primeiro, explore como o par√¢metro -R manipula a sa√≠da do comando sort. Repita esse comando algumas vezes em sua m√°quina:

$ sed -n /Main Office/p mypasswd | cut -d: -f5 | cut -d, -f1 | sort -R
Eis uma solu√ß√£o para o problema:

$ sed -n /Main Office/p mypasswd | cut -d: -f5 | cut -d, -f1 | sort -R | head -1
Quantas pessoas trabalham em Human Resources, Engineering e Accounts Payable? (pense em explorar o comando uniq.)

Continue incrementando o que voc√™ aprendeu nos exerc√≠cios anteriores. Tente o seguinte:

$ sed -n /Main Office/p mypasswd
$ sed -n /Main Office/p mypasswd | cut -d, -f2
Note que n√£o nos preocupamos com o delimitador :. Queremos somente o segundo campo quando dividimos as linhas pelos caracteres ,.

$ sed -n /Main Office/p mypasswd | cut -d, -f2 | uniq -c
      4 Human Resources
      1 Engineering
      2 Accounts Payable
O comando uniq mostra apenas as linhas √∫nicas (n√£o as linhas repetidas) e o par√¢metro -c diz ao uniq para contar as ocorr√™ncias de linhas iguais. Mas fique esperto: uniq considera apenas as linhas adjacentes. Quando esse n√£o for o caso, ser√° preciso usar o comando sort.

Agora, vamos preparar um arquivo CSV (valores separados por v√≠rgula) para poder importar facilmente, do arquivo mypasswd do exemplo anterior, o arquivo persons.csv para o LibreOffice. O conte√∫do do arquivo ter√° o seguinte formato:

First Name,Last Name,Position
Carol,Smith,Human Resources
...
John,Chapel,Accounts Payable
Dica: use os comandos sed, cut e paste para obter os resultados desejados. Note que a v√≠rgula (,) ser√° o delimitador desse arquivo.

Comece com os comandos sed e cut, incrementando o que aprendemos nos exerc√≠cios anteriores:

$ sed -n /Main Office/p mypasswd | cut -d: -f5 | cut -d" " -f1 > firstname
Agora temos o arquivo firstname com o primeiro nome dos funcion√°rios.

$ sed -n /Main Office/p mypasswd | cut -d: -f5 | cut -d" " -f2 | cut -d, -f1 > lastname
Agora temos o arquivo lastname com o sobrenome de cada funcion√°rio.

A seguir, vamos determinar o departamento em que cada funcion√°rio trabalha:

$ sed -n /Main Office/p mypasswd | cut -d: -f5 | cut -d, -f2 > department
Antes de trabalharmos na resposta final, tente os seguintes comandos para ver que tipo de sa√≠da eles geram:

$ cat firstname lastname department
$ paste firstname lastname department
E a solu√ß√£o √©:

$ paste firstname lastname department | tr '\t' ,
$ paste firstname lastname department | tr '\t' , > names.csv
Aqui, usamos o comando tr para traduzir \t, o separador de tabula√ß√£o, por um ,. tr √© bastante √∫til quando precisamos trocar um caractere por outro. N√£o deixe de ler as p√°ginas de manual de tr e paste. Por exemplo, podemos usar a op√ß√£o -d para o delimitador, para tornar o comando anterior menos complexo:

$ paste -d, firstname lastname station
Usamos o comando paste aqui para voc√™ se acostumar mais com ele. No entanto, poder√≠amos ter executado facilmente todas as tarefas em uma √∫nica cadeia de comando:

$ sed -n /Main Office/p mypasswd | cut -d: -f5 | cut -d, -f1,2 | tr ' ' , > names.csv
Suponha que a planilha people.csv criada no exerc√≠cio anterior seja um arquivo importante e queremos ter certeza de que ningu√©m vai adulter√°-lo desde o momento do envio at√© a recep√ß√£o pelo destinat√°rio. Como podemos garantir a integridade desse arquivo usando md5sum?

Se voc√™ consultar as p√°ginas de manual de md5sum, sha256sum e sha512sum, ver√° que todas come√ßam com o seguinte texto:

‚Äúcompute and check XXX message digest‚Äù

Onde ‚ÄúXXX‚Äù √© o algoritmo que ser√° usado para criar esse message digest (resumo de mensagens).

Usaremos md5sum como exemplo e, mais tarde, voc√™ poder√° tentar com os outros comandos.

$ md5sum names.csv
61f0251fcab61d9575b1d0cbf0195e25  names.csv
Agora, por exemplo, voc√™ pode disponibilizar o arquivo atrav√©s de um servi√ßo de ftp seguro e enviar o resumo de mensagens gerado usando outro meio de comunica√ß√£o seguro. Se o arquivo tiver sido ligeiramente alterado, o resumo de mensagens ser√° totalmente diferente. Para comprovar, edite names.csv e troque James por Jones, como demonstramos aqui:

$ sed -i.backup s/James/Jones/ names.csv
$ md5sum names.csv
f44a0d68cb480466099021bf6d6d2e65  names.csv
Sempre que voc√™ disponibilizar arquivos para download, √© aconselh√°vel distribuir tamb√©m um resumo de mensagens correspondente para que as pessoas que baixarem aquele arquivo possam produzir um novo resumo de mensagens e comparar com o original. Se voc√™ visitar o site https://kernel.org, encontrar√° a p√°gina https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/sha256sums.asc, onde pode obter o sha256sum de todos os arquivos dispon√≠veis para download.

Voc√™ prometeu a si mesmo que leria 100 linhas por dia de um livro cl√°ssico e decidiu come√ßar com Mariner and Mystic de Herman Melville. Desenvolva um comando usando split para dividir este livro em se√ß√µes de 100 linhas cada. Para obter o livro em formato de texto simples, pesquise em https://www.gutenberg.org.

Primeiro, baixamos o livro completo do site do Project Gutenberg, onde voc√™ pode obter este e outros livros dispon√≠veis em dom√≠nio p√∫blico.

$ wget https://www.gutenberg.org/files/50461/50461-0.txt
Pode ser preciso instalar wget se ainda n√£o estiver presente no sistema. Outra alternativa √© usar curl. Use less para verificar o livro:

$ less 50461-0.txt
Agora, vamos dividir o livro em trechos de 100 linhas cada:

$ split -l 100 -d 50461-0.txt melville
50461-0.txt √© o arquivo que dividiremos. melville ser√° o prefixo dos arquivos divididos. -l 100 especifica o n√∫mero de linhas e a op√ß√£o -d diz ao split para numerar os arquivos (usando o sufixo fornecido). Podemos usar nl em qualquer um dos arquivos divididos (provavelmente n√£o no √∫ltimo) e confirmar que todos eles t√™m 100 linhas.

Usando ls -l no diret√≥rio /etc, que tipo de listagem obtemos? Usando o comando cut na sa√≠da do comando ls fornecido, como exibir apenas os nomes dos arquivos? E quanto ao nome dos arquivos e seu propriet√°rio? Junto com os comandos ls -l e cut, utilize o comando tr para espremer diversas ocorr√™ncias de um espa√ßo em um √∫nico espa√ßo para auxiliar na formata√ß√£o da sa√≠da com um comando cut.

O comando ls sozinho fornece apenas os nomes dos arquivos. Podemos, no entanto, preparar a sa√≠da do ls -l (a lista longa) para extrair informa√ß√µes mais espec√≠ficas.

$ ls -l /etc | tr -s ' ' ,
drwxr-xr-x,3,root,root,4096,out,24,16:58,acpi
-rw-r--r--,1,root,root,3028,dez,17,2018,adduser.conf
-rw-r--r--,1,root,root,10,out,2,17:38,adjtime
drwxr-xr-x,2,root,root,12288,out,31,09:40,alternatives
-rw-r--r--,1,root,root,401,mai,29,2017,anacrontab
-rw-r--r--,1,root,root,433,out,1,2017,apg.conf
drwxr-xr-x,6,root,root,4096,dez,17,2018,apm
drwxr-xr-x,3,root,root,4096,out,24,16:58,apparmor
drwxr-xr-x,9,root,root,4096,nov,6,20:20,apparmor.d
O par√¢metro -s instrui tr a reduzir os espa√ßos repetidos a uma √∫nica inst√¢ncia de um espa√ßo. O comando tr funciona para qualquer tipo de caractere repetitivo que voc√™ especificar. Em seguida, substitu√≠mos os espa√ßos por uma v√≠rgula ,. Na verdade, n√£o precisamos substituir os espa√ßos em nosso exemplo, ent√£o apenas omitiremos ,.

$ ls -l /etc | tr -s ' '
drwxr-xr-x 3 root root 4096 out 24 16:58 acpi
-rw-r--r-- 1 root root 3028 dez 17 2018 adduser.conf
-rw-r--r-- 1 root root 10 out 2 17:38 adjtime
drwxr-xr-x 2 root root 12288 out 31 09:40 alternatives
-rw-r--r-- 1 root root 401 mai 29 2017 anacrontab
-rw-r--r-- 1 root root 433 out 1 2017 apg.conf
drwxr-xr-x 6 root root 4096 dez 17 2018 apm
drwxr-xr-x 3 root root 4096 out 24 16:58 apparmor
Se quisermos apenas os nomes dos arquivos, s√≥ precisamos exibir o nono campo:

$ ls -l /etc | tr -s ' ' | cut -d" " -f9
Para o nome de arquivo e seu propriet√°rio, precisamos do nono e do terceiro campos:

$ ls -l /etc | tr -s ' ' | cut -d" " -f9,3
E se s√≥ precisarmos dos nomes das pastas e seu propriet√°rio?

$ ls -l /etc | grep ^d | tr -s ' ' | cut -d" " -f9,3
Este exerc√≠cio pressup√µe que voc√™ est√° em uma m√°quina real (n√£o virtual). Tamb√©m √© preciso ter um pendrive √† m√£o. Releia as p√°ginas de manual do comando tail e descubra como seguir um arquivo conforme adicionamos texto a ele. Enquanto monitora a sa√≠da de um comando tail no arquivo /var/log/syslog, insira um pendrive. Escreva o comando completo que usaria para obter o Produto (Product), o Fabricante (Manufacturer) e a quantidade total de mem√≥ria (Blocks) do seu pendrive.

$ tail -f /var/log/syslog | grep -i 'product\:\|blocks\|manufacturer'
Nov  8 06:01:35 brod-avell kernel: [124954.369361] usb 1-4.3: Product: Cruzer Blade
Nov  8 06:01:35 brod-avell kernel: [124954.369364] usb 1-4.3: Manufacturer: SanDisk
Nov  8 06:01:37 brod-avell kernel: [124955.419267] sd 2:0:0:0: [sdc] 61056064 512-byte logical blocks: (31.3 GB/29.1 GiB)
Claro que isto √© um exemplo e os resultados podem variar dependendo do fabricante do seu pendrive. Observe que agora usamos o par√¢metro -i com o comando grep, pois n√£o sabemos se as strings que procuramos est√£o em mai√∫sculas ou min√∫sculas. Tamb√©m usamos | como um OR (ou) l√≥gico, ent√£o procuramos por linhas contendo product OR blocks OR manufacturer.


https://learning.lpi.org/pt/learning-materials/101-500/103/103.3/103.3_01/

103.3 Gerenciamento basico de arquivos

ls -l

ls -ld -Lista diretorios

ls -lh h human

ls -la Lista arquivos ocultos

* representa zero uma ou mais ocorrencias do caracter

? representa uma ocorrencia

[] qualquer ocorrencia inserido nos colchetes

Ex: [0-9]
Ex: [?0-9]


Ex: find /home -name *.png - Busque dentro do diretorio /home, por nome, qualquer ocorrencia * do .png

cp -r animal/* forest -Nesse caso todo o de animal sera copiado para forest

$ rm *ate* 
Os arquivos com nomes iniciando com zero, uma ou mais ocorr√™ncias de qualquer caractere, seguidos das letras ate e terminando com zero, uma ou mais ocorr√™ncias de qualquer caractere ser√£o removidos.

O ponto de interroga√ß√£o
O ponto de interroga√ß√£o (?) corresponde a uma √∫nica ocorr√™ncia de um caractere.

Considere a listagem:

$ ls
last.txt    lest.txt    list.txt    third.txt   past.txt
Para retornar apenas os arquivos que come√ßam com l seguido por qualquer caractere √∫nico e os caracteres st.txt, usamos o caractere curinga ponto de interroga√ß√£o (?):

$ ls l?st.txt
last.txt    lest.txt    list.txt
Apenas os arquivos last.txt, lest.txt e list.txt s√£o exibidos, pois correspondem aos crit√©rios dados.

Da mesma maneira,

$ ls ??st.txt
last.txt    lest.txt    list.txt    past.txt
exibe os arquivos cujos nomes iniciam com quaisquer dois caracteres seguidos pelo texto st.txt.


Caracteres entre chaves
Os curingas entre colchetes correspondem a qualquer ocorr√™ncia do(s) caractere(s) entre colchetes:

$ ls l[aef]st.txt
last.txt    lest.txt
Este comando listaria todos os arquivos come√ßando com l seguido por qualquer um dos caracteres do conjunto aef e terminando com st.txt.

Os colchetes tamb√©m podem indicar intervalos:

$ ls l[a-z]st.txt
last.txt    lest.txt    list.txt
Esse comando exibe todos os arquivos com nomes come√ßando com l seguido por qualquer letra min√∫scula no intervalo de a a z e terminando com st.txt.


Combinando caracteres curinga
Os caracteres curinga podem ser combinados, como em:

$ ls
last.txt    lest.txt    list.txt    third.txt   past.txt
$ ls [plf]?st* 
list.txt    last.txt    past.txt
O primeiro componente curinga ([plf]) corresponde a qualquer um dos caracteres p, l ou f. O segundo componente curinga (?) corresponde a qualquer caractere √∫nico. O terceiro componente curinga (*) corresponde a zero, uma ou m√∫ltiplas ocorr√™ncias de qualquer caractere.

Existem outros caracteres curinga, como o sinal de mais (+), usado para representar caractere(s) que aparecem uma ou mais vezes:

$ ls
file1.txt file.txt file23.txt fisher.txt fom23.txt
$ ls f*[0-9]+.txt
file1.txt file23.txt fom23.txt
O comando anterior exibe todos os arquivos que come√ßam com a letra f, seguido por qualquer conjunto de letras, pelo menos uma ocorr√™ncia de um d√≠gito e termina com .txt. Observe que file.txt n√£o √© exibido, pois n√£o corresponde a esses crit√©rios.

103.3 Gerenciamento de arquivos

$ find . -name "myfile.txt"
./myfile.txt
O caminho inicial, neste caso, √© o diret√≥rio atual. A op√ß√£o -name especifica que a pesquisa √© baseada no nome do arquivo. myfile.txt √© o nome do arquivo a ser pesquisado. Ao usar globbing de arquivo, inclua sempre a express√£o entre aspas:


# find . -name "ftu.txt" . Significa no diretorio atual

Usando crit√©rios para acelerar a pesquisa
Use find para localizar arquivos com base em tipo, tamanho ou hora. Se especificarmos uma ou mais op√ß√µes, os resultados desejados s√£o obtidos em menos tempo.

As op√ß√µes para localizar arquivos com base no tipo incluem:

-type f
busca por arquivos.

-type d
busca por diret√≥rios.

-type l
busca por links simb√≥licos.

$ find . -type d -name "example" Busca no diretorio atual e abaixo dele.

Localizando arquivos por hora de modifica√ß√£o
find tamb√©m permite filtrar uma hierarquia de diret√≥rios com base em quando o arquivo foi modificado:

$ sudo find / -name "*.conf" -mtime 7
/etc/logrotate.conf
Este comando procura por todos os arquivos em todo o sistema de arquivos (o caminho inicial √© o diret√≥rio raiz, ou seja, /) que terminam com os caracteres .conf e que foram modificados nos √∫ltimos sete dias. Este comando exige privil√©gios elevados para acessar diret√≥rios na base da estrutura de diret√≥rios do sistema, da√≠ o uso de sudo neste caso. O argumento passado para mtime representa o n√∫mero de dias desde a √∫ltima modifica√ß√£o do arquivo.

Localizando arquivos por tamanho
O find tamb√©m pode localizar arquivos por tamanho. Por exemplo, se quisermos encontrar arquivos maiores que 2G em /var:

$ sudo find /var -size +2G
/var/lib/libvirt/images/debian10.qcow2
/var/lib/libvirt/images/rhel8.qcow2
A op√ß√£o -size exibe arquivos de tamanhos correspondentes ao argumento passado. Eis alguns exemplos de argumentos:

-size 100b
arquivos com exatamente 100 bytes.

-size +100k
arquivos maiores que 100 kilobytes.

-size -20M
arquivos menores que 20 megabytes.

-size +2G
arquivos maiores que 2 gigabytes.


O que fazer com os resultados
Uma vez que a pesquisa √© feita, √© poss√≠vel realizar uma a√ß√£o no conjunto de resultados usando -exec:

$ find . -name "*.conf" -exec chmod 644 '{}' \;
Esse comando filtra todos os objetos no diret√≥rio atual (.) e abaixo dele para nomes de arquivo terminando com .conf e em seguida executa o comando chmod 644 para modificar as permiss√µes de arquivo nos resultados.

Por enquanto, n√£o se preocupe com o significado de '{}' \;, pois isso ser√° discutido mais adiante.

Usando o grep para filtrar por arquivos com base no conte√∫do
grep √© usado para buscar pela ocorr√™ncia de uma palavra-chave.

Considere uma situa√ß√£o na qual precisamos encontrar arquivos com base no conte√∫do:

$ find . -type f -exec grep "lpi" '{}' \; -print
./.bash_history
Alpine/M
helping/M
Esse comando busca, na hierarquia de diret√≥rios atual (.), por objetos que s√£o arquivos (-type f) e em seguida executa o comando grep "lpi" para cada arquivo que satisfa√ßa as condi√ß√µes. Os arquivos que atendem a essas condi√ß√µes s√£o impressos na tela (-print). As chaves ({}) servem para reservar o espa√ßo para os resultados encontrados por find. As {} s√£o postas entre aspas simples (') para evitar passar arquivos com nomes contendo caracteres especiais para o grep. O comando -exec √© conclu√≠do com um ponto e v√≠rgula (;), que deve ser escapado (\;) para n√£o ser interpretado pelo shell.

A op√ß√£o -delete, se colocada no final de uma express√£o, excluiria todos os arquivos correspondentes √† descri√ß√£o. Esta op√ß√£o deve ser usada quando voc√™ tiver certeza de que os resultados correspondem apenas aos arquivos que deseja excluir.

No exemplo abaixo, find localiza todos os arquivos na hierarquia come√ßando no diret√≥rio atual e, em seguida, exclui todos os arquivos que terminam com os caracteres .bak:

$ find . -name "*.bak" -delete


Pense no tar como uma ferramenta que cria uma cola na qual os arquivos podem ser grudados, agrupados e facilmente movidos.

O tar tamb√©m tem a capacidade de extrair arquivos tar, exibir uma lista dos arquivos inclu√≠dos no pacote e adicionar mais arquivos a um pacote existente.

A sintaxe do comando tar √© a seguinte:

tar [OPERATION_AND_OPTIONS] [ARCHIVE_NAME] [FILE_NAME(S)]
OPERATION
Somente um argumento de opera√ß√£o √© permitido e exigido. As opera√ß√µes mais frequentemente usadas s√£o:

--create (-c)
Cria um novo arquivo tar.

--extract (-x)
Extrai o pacote inteiro ou um ou mais arquivos de um pacote.

--list (-t)
Exibe uma lista dos arquivos inclu√≠dos no pacote.

OPTIONS
As op√ß√µes usadas com mais frequ√™ncia s√£o:

--verbose (-v)
Mostra os arquivos que est√£o sendo processados pelo comando tar.

--file=archive=name (-f archive-name)
Especifica o nome de arquivo do pacote.

ARCHIVE_NAME
O nome do arquivo de pacote.

FILE_NAME(S)
Uma lista separada por espa√ßos com os nomes de arquivos a serem extra√≠dos. Se n√£o estiver presente, o pacote inteiro √© extra√≠do.

Criando um arquivo de pacote
Digamos que temos um diret√≥rio chamado stuff no diret√≥rio atual e queremos salv√°-lo em um arquivo chamado archive.tar. Executar√≠amos para isso o seguinte comando:

$ tar -cvf archive.tar stuff
stuff/
stuff/service.conf
Eis o que essas op√ß√µes significam de fato:

-c
Cria um arquivo de pacote.

-v
Exibe o progresso no terminal enquanto o arquivo de pacote √© criado. Tamb√©m chamado de modo ‚Äúverboso‚Äù. O -v sempre √© opcional nesses comandos, mas √© √∫til.

-f
Permite especificar o nome de arquivo do pacote.

Em geral, para arquivar um √∫nico diret√≥rio ou um √∫nico arquivo no Linux, usamos:

tar -cvf NAME-OF-ARCHIVE.tar /PATH/TO/DIRECTORY-OR-FILE
Note
O tar funciona de maneira recursiva. Ele realiza a a√ß√£o solicitada em todos os diret√≥rios subsequentes dentro do diret√≥rio especificado.

Para empacotar diversos diret√≥rios de uma vez s√≥, listamos todos eles delimitando-os por um espa√ßo na se√ß√£o /PATH/TO/DIRECTORY-OR-FILE:

$ tar -cvf archive.tar stuff1 stuff2
Isso cria um arquivo de pacote com stuff1 e stuff2 em archive.tar

Extraindo um pacote
Podemos extrair um arquivo de pacote usando o tar:

$ tar -xvf archive.tar
stuff/
stuff/service.conf
Isso extrai o conte√∫do de archive.tar para o diret√≥rio atual.

Este comando √© igual ao comando de cria√ß√£o de pacotes usado acima, exceto porque a op√ß√£o -x substitui a op√ß√£o -c.

Para extrair o conte√∫do do pacote para um diret√≥rio espec√≠fico, usamos -C:

$ tar -xvf archive.tar -C /tmp
Isso extrai o conte√∫do de archive.tar para o diret√≥rio /tmp.

$ ls /tmp
stuff
Compactando com o tar
O comando tar do GNU inclu√≠do nas distribui√ß√µes Linux pode criar um arquivo .tar e, em seguida, compact√°-lo com a compacta√ß√£o gzip ou bzip2 em um √∫nico comando:

$ tar -czvf name-of-archive.tar.gz stuff
Este comando criaria um arquivo compactado usando o algoritmo gzip (-z).

Embora a compress√£o gzip seja mais freq√ºentemente usada para criar arquivos .tar.gz ou .tgz, o tar tamb√©m suporta a compress√£o bzip2. Isso permite a cria√ß√£o de arquivos compactados bzip2, geralmente chamados de arquivos .tar.bz2, .tar.bz ou .tbz.

Para isso, substitu√≠mos -z, de gzip, por -j, de bzip2:

$ tar -cjvf name-of-archive.tar.bz stuff
Para descompactar o arquivo, substitu√≠mos -c por -x, onde x significa ‚Äúextract‚Äù:

$ tar -xzvf archive.tar.gz
O gzip √© mais r√°pido, mas geralmente compacta um pouco menos, de modo que o arquivo obtido √© um pouco maior. O bzip2 √© mais lento, mas comprime um pouco mais, ent√£o o arquivo fica um pouco menor. Em geral, por√©m, gzip e bzip2 s√£o praticamente a mesma coisa; ambos funcionam de forma semelhante.

Outra alternativa seria aplicar a compress√£o gzip ou bzip2 usando o comando gzip para as compress√µes gzip e bzip para as compress√µes bzip. Por exemplo, para aplicar a compacta√ß√£o gzip, use:

gzip FILE-TO-COMPRESS
gzip
cria o arquivo compactado com o mesmo nome, mas com a termina√ß√£o .gz.

gzip
remove os arquivos originais ap√≥s criar o arquivo compactado.

O comando bzip2 funciona de maneira semelhante.

Para descompactar os arquivos usamos gunzip ou bunzip2, dependendo do algoritmo usado para compact√°-los.

O comando cpio
cpio significa ‚Äúcopy in, copy out‚Äù. √â usado para processar arquivo de pacote como os arquivos .cpio ou .tar.

O cpio executa as seguintes opera√ß√µes:

Copiar arquivos para um pacote.

Extrair arquivos de um pacote.

Ele usa a lista de arquivos da entrada padr√£o (principalmente a sa√≠da de ls).

Para criar um arquivo cpio, usamos:

$ ls | cpio -o > archive.cpio
A op√ß√£o -o instrui o cpio a criar uma sa√≠da. Neste caso, o arquivo de sa√≠da criado √© archive.cpio. O comando ls lista o conte√∫do do diret√≥rio atual que ser√° empacotado.

Para extrair o arquivo de pacote, usamos:

$ cpio -id < archive.cpio
A op√ß√£o -i √© usada para realizar a extra√ß√£o. A op√ß√£o -d cria a pasta de destino. O caractere < representa a entrada padr√£o. O arquivo de entrada a ser extra√≠do √© archive.cpio.

O comando dd
O dd copia dados de um local para outro. A sintaxe de linha de comando de dd difere de muitos outros programas Unix, pois ele usa a sintaxe option = value para as op√ß√µes de linha de comando ao inv√©s dos formatos padr√£o GNU -option value ou --option=value:

$ dd if=oldfile of=newfile
Este comando copia o conte√∫do de oldfile para newfile, onde if= √© o arquivo de entrada e of= refere-se ao arquivo de sa√≠da.

Note
O comando dd normalmente n√£o exibe nada na tela at√© que o comando seja conclu√≠do. Ao fornecer a op√ß√£o status=progress, o console exibe o andamento do trabalho realizado pelo comando. Por exemplo: dd status=progress if=oldfile of=newfile.

O dd tamb√©m √© usado para alterar dados para mai√∫sculas/min√∫sculas ou para escrever diretamente em dispositivos de bloco como /dev/sdb:

$ dd if=oldfile of=newfile conv=ucase
Esse comando copiaria todo o conte√∫do de oldfile para newfile e colocaria todo o texto em mai√∫sculas.

O comando a seguir faria backup do disco r√≠gido inteiro localizado em /dev/sda para um arquivo de nome backup.dd:

$ dd if=/dev/sda of=backup.dd bs=4096

103.4 Redirecionamento de saida
Por padr√£o, apenas o conte√∫do que chega a stdout √© redirecionado. Isso ocorre porque o valor num√©rico do descritor de arquivo deve ser especificado logo antes do s√≠mbolo de maior que e, quando n√£o especificado, o Bash redireciona a sa√≠da padr√£o. Portanto, usar > √© equivalente a usar 1> (o valor do descritor de arquivo de stdout √© 1).

Para capturar o conte√∫do de stderr, o redirecionamento 2> deve ser usado. A maioria dos programas de linha de comando enviam informa√ß√µes de depura√ß√£o e mensagens de erro para o canal de erro padr√£o. √â poss√≠vel, por exemplo, capturar a mensagem de erro gerada por uma tentativa de leitura de um arquivo inexistente:

$ cat /proc/cpu_info 2>/tmp/error.txt
$ cat /tmp/error.txt
cat: /proc/cpu_info: No such file or directory
Tanto stdout quanto stderr s√£o redirecionados para o mesmo destino com &> ou >&. √â importante n√£o colocar nenhum espa√ßo ao lado do "e" comercial, 

stdout = &> ou 1>

stderr = >& ou 2>

 Por exemplo, 1>&2 redireciona stdout para stderr. Para fazer o oposto, stderr para stdout, devemos usar 2>&1.

Por exemplo, um redirecionamento para gravar stderr e stdout em um arquivo chamado log.txt pode ser escrito como >log.txt 2>&1

Para simplesmente descartar a sa√≠da de um comando, seu conte√∫do pode ser redirecionado para o arquivo especial /dev/null. Por exemplo, >log.txt 2>/dev/null salva o conte√∫do de stdout no arquivo log.txt e descarta o stderr. O arquivo /dev/null pode ser escrito por qualquer usu√°rio, mas nenhum dado pode ser recuperado dele, pois n√£o √© armazenado em lugar nenhum.


 Os arquivos s√£o substitu√≠dos pelos redirecionamentos de sa√≠da, a menos que a op√ß√£o noclobber esteja habilitada no Bash, o que pode ser feito para a sess√£o atual com o comando set -o noclobber ou set -C:

$ set -o noclobber
$ cat /proc/cpu_info 2>/tmp/error.txt
-bash: /tmp/error.txt: cannot overwrite existing file
Para remover a op√ß√£o noclobber da sess√£o atual, execute set +o noclobber ou set +C. Para tornar a op√ß√£o noclobber persistente, ela deve ser inclu√≠da no perfil Bash do usu√°rio ou no perfil de todo o sistema.

Mesmo com a op√ß√£o noclobber habilitada, √© poss√≠vel anexar dados redirecionados ao conte√∫do existente. Usamos para isso um redirecionamento escrito com dois s√≠mbolos de maior que, >>:

$ cat /proc/cpu_info 2>>/tmp/error.txt
$ cat /tmp/error.txt
cat: /proc/cpu_info: No such file or directory
cat: /proc/cpu_info: No such file or directory

 O comando uniq, como a maioria dos utilit√°rios de linha de comando para processamento de texto, aceita os dados enviados para stdin por padr√£o:

$ uniq -c </tmp/error.txt
      2 cat: /proc/cpu_info: No such file or directory
A op√ß√£o -c faz com que o uniq exiba quantas vezes uma linha repetida aparece no texto. Como o valor num√©rico do descritor de arquivo redirecionado foi suprimido, o comando de exemplo √© equivalente a uniq -c 0</tmp/error.txt


Substitui√ß√£o de comando
Outro m√©todo para capturar a sa√≠da de um comando √© a substitui√ß√£o de comando. Ao colocar um comando entre crases, o Bash o substitui por sua sa√≠da padr√£o. O exemplo a seguir mostra como usar o stdout de um programa como argumento para outro programa:

$ mkdir `date +%Y-%m-%d`
$ ls
2019-09-05
A sa√≠da do programa date, a data atual formatada como ano-m√™s-dia, foi usada como um argumento para criar um diret√≥rio com o mkdir. Um resultado id√™ntico √© obtido usando $() em vez de crases:

$ rmdir 2019-09-05
$ mkdir $(date +%Y-%m-%d)
$ ls
2019-09-05
O mesmo m√©todo pode ser usado para armazenar a sa√≠da de um comando como uma vari√°vel:

$ OS=`uname -o`
$ echo $OS
GNU/Linux


O programa identify √© parte do ImageMagick, um conjunto de ferramentas de linha de comando para inspecionar, converter e editar a maioria dos tipos de arquivo de imagem. No exemplo, o xargs pegou todos os caminhos listados por find e os colocou como argumentos para identify, que ent√£o exibe as informa√ß√µes para cada arquivo formatado conforme exigido pela op√ß√£o -format. Os arquivos encontrados pelo find no exemplo s√£o imagens contendo o logotipo da distribui√ß√£o em um sistema de arquivos Debian. -format √© um par√¢metro para identify, n√£o para xargs.

A op√ß√£o -n 1 exige que o xargs execute o comando fornecido com apenas um argumento por vez. No caso do exemplo, em vez de passar todos os caminhos encontrados por find como uma lista de argumentos para identify, o uso de xargs -n 1 executaria o comando identify para cada caminho separadamente. Usar -n 2 executaria o identify com dois caminhos como argumentos, -n 3 com tr√™s caminhos como argumentos e assim por diante. Da mesma forma, quando o xargs processa conte√∫dos com v√°rias linhas‚Äâ‚Äî‚Äâcomo √© o caso com a entrada fornecida por find‚Äâ‚Äî‚Äâa op√ß√£o -L pode ser usada para limitar quantas linhas ser√£o usadas como argumentos por execu√ß√£o do comando.

Note
Pode ser desnecess√°rio usar o xargs com a op√ß√£o -n 1 ou -L 1 para processar a sa√≠da gerada pelo find. O comando find tem a op√ß√£o -exec para executar um comando determinado para cada item do resultado da busca.

Se os caminhos contiverem caracteres de espa√ßo, √© importante executar o find com a op√ß√£o -print0. Esta op√ß√£o instrui o find a usar um caractere nulo entre cada entrada para que a lista possa ser analisada corretamente por xargs (a sa√≠da foi suprimida):

$ find . -name '*avi' -print0 -o -name '*mp4' -print0 -o -name '*mkv' -print0 | xargs -0 du | sort -n
A op√ß√£o -0 diz ao xargs que o caractere nulo deve ser usado como separador. Dessa forma, os caminhos de arquivo fornecidos pelo find s√£o analisados corretamente, mesmo se contiverem espa√ßos em branco ou outros caracteres especiais. O exemplo anterior mostra como usar o comando du para descobrir o uso de espa√ßo em disco por cada arquivo encontrado e em seguida classificar os resultados por tamanho. A sa√≠da foi suprimida para fins de concis√£o. Observe que para cada crit√©rio de pesquisa √© necess√°rio incluir a op√ß√£o -print0 para find.

Por padr√£o, o xargs coloca por √∫ltimo os argumentos do comando executado. Para mudar esse comportamento, usamos a op√ß√£o -I:

$ find . -mindepth 2 -name '*avi' -print0 -o -name '*mp4' -print0 -o -name '*mkv' -print0 | xargs -0 -I PATH mv PATH ./
No √∫ltimo exemplo, todo arquivo encontrado por find √© movido para o diret√≥rio atual. Como o(s) caminho(s) de origem devem ser informados para o mv antes do caminho de destino, um termo de substitui√ß√£o √© dado √† op√ß√£o -I do xargs, que √© ent√£o apropriadamente colocado junto a mv. Ao usar o caractere nulo como separador, n√£o √© necess√°rio colocar o termo de substitui√ß√£o entre aspas.


Respostas aos Exerc√≠cios Guiados
√â conveniente salvar a data de execu√ß√£o das a√ß√µes realizadas por scripts autom√°ticos. O comando date +%Y-%m-%d mostra a data atual no formato ano-m√™s-dia. Como a sa√≠da desse comando pode ser armazenada em uma vari√°vel do shell chamada TODAY usando a substitui√ß√£o de comando?

$ TODAY=`date +%Y-%m-%d`
ou

$ TODAY=$(date +%Y-%m-%d)
Usando o comando echo, como o conte√∫do da vari√°vel TODAY pode ser enviado para a sa√≠da padr√£o do comando sed s/-/./g?

$ echo $TODAY | sed s/-/./g
Como a sa√≠da do comando date +%Y-%m-%d pode ser usada como uma Here string para o comando sed s/-/./g?

$ sed s/-/./g <<< `date +%Y-%m-%d`
ou

$ sed s/-/./g <<< $(date +%Y-%m-%d)
O comando convert image.jpeg -resize 25% small/image.jpeg cria uma vers√£o menor de image.jpeg e coloca a imagem resultante em um arquivo com o mesmo nome dentro do subdiret√≥rio small. Usando o xargs, como √© poss√≠vel executar o mesmo comando para todas as imagens listadas no arquivo filelist.txt?

$ xargs -I IMG convert IMG -resize 25% small/IMG < filelist.txt
ou

$ cat filelist.txt | xargs -I IMG convert IMG -resize 25% small/IMG
Respostas aos Exerc√≠cios Explorat√≥rios
Uma rotina de backup simples cria periodicamente uma imagem da parti√ß√£o /dev/sda1 com dd < /dev/sda1 > sda1.img. Para realizar futuras verifica√ß√µes de integridade de dados, a rotina tamb√©m gera um hash SHA1 do arquivo com sha1sum < sda1.img > sda1.sha1. Adicionando pipes e o comando tee, como esses dois comandos poderiam ser combinados em um s√≥?

# dd < /dev/sda1 | tee sda1.img | sha1sum > sda1.sha1
O comando tar √© usado para empacotar muitos arquivos em um s√≥, preservando a estrutura de diret√≥rios. A op√ß√£o -T permite especificar um arquivo contendo os caminhos a arquivar. Por exemplo, find /etc -type f | tar -cJ -f /srv/backup/etc.tar.xz -T - cria o arquivo tar compactado etc.tar.xz a partir da lista fornecida pelo comando find (a op√ß√£o -T - indica a entrada padr√£o como a lista de caminhos). Para evitar poss√≠veis erros de an√°lise devido a caminhos que cont√™m espa√ßos, quais op√ß√µes deveriam estar presentes para os comandos find e tar?

Options -print0 and --null:

$ find /etc -type f -print0 | tar -cJ -f /srv/backup/etc.tar.xz -T - --null
Em vez de abrir uma nova sess√£o remota do shell, o comando ssh pode simplesmente executar um comando indicado como argumento: ssh user@storage "remote command". Dado que ssh tamb√©m permite redirecionar a sa√≠da padr√£o de um programa local para a entrada padr√£o do programa remoto, como o comando cat canalizaria um arquivo local chamado etc.tar.gz para /srv/backup/etc.tar.gz em user@storage atrav√©s de ssh?

$ cat etc.tar.xz | ssh user@storage "cat > /srv/backup/etc.tar.xz"
ou

$ ssh user@storage "cat > /srv/backup/etc.tar.xz" < etc.tar.xz

Monitorando processos

Comando watch


Monitoramento de processos
Um processo ou tarefa √© uma inst√¢ncia de um programa em execu√ß√£o. Assim, criamos novos processos toda vez que digitamos comandos no terminal.

O comando watch executa um programa periodicamente (por padr√£o, a cada 2 segundos) e nos permite observar a mudan√ßa da sa√≠da do programa ao longo do tempo. Por exemplo, podemos monitorar como a m√©dia de trabalho muda conforme mais processos s√£o executados digitando watch uptime:

Every  2.0s: uptime          debian: Tue Aug 20 23:31:27 2019

 23:31:27 up 21 min,  1 user,  load average: 0.00, 0.00, 0.00
O comando roda at√© ser interrompido, ent√£o ter√≠amos de par√°-lo com Ctrl+C. Obtemos duas linhas na sa√≠da: a primeira corresponde ao watch e nos informa a frequ√™ncia com que o comando ser√° executado (Every 2.0s: uptime), qual o comando/programa a observar (uptime) al√©m do nome do host e a data (debian: Tue Aug 20 23:31:27 2019). A segunda linha da sa√≠da √© o tempo de atividade e inclui a hora (23:31:27), o tempo em que o sistema est√° ativo (up 21 min), o n√∫mero de usu√°rios ativos (1 user) e a carga m√©dia do sistema ou o n√∫mero de processos em execu√ß√£o ou em estado de espera nos √∫ltimos 1, 5 e 15 minutos (load average: 0.00, 0.00, 0.00).


Enviando sinais para processos: kill
Cada processo possui um identificador de processo ou PID exclusivo. Uma maneira de descobrir o PID de um processo √© usar o comando pgrep seguido pelo nome do processo:

$ pgrep sleep
1201
Note
O identificador de um processo tamb√©m pode ser descoberto com o comando pidof (p.ex. pidof sleep).

Como no caso do pgrep, o comando pkill elimina um processo com base em seu nome:

$ pkill sleep
[1]+  Terminated              sleep 60
Para eliminar v√°rias inst√¢ncias do mesmo processo, o comando killall pode ser usado:

$ sleep 60 &
[1] 1246
$ sleep 70 &
[2] 1247
$ killall sleep
[1]-  Terminated              sleep 60
[2]+  Terminated              sleep 70
Tanto pkill quanto killall funcionam da mesma maneira que kill, ou seja, enviam um sinal de encerramento para o(s) processo(s) especificado(s). Se nenhum sinal for fornecido, o padr√£o SIGTERM √© enviado. No entanto, kill s√≥ aceita um ID de trabalho ou de processo como argumento.

Os sinais podem ser especificados por:

Nome:

$ kill -SIGHUP 1247
N√∫mero:

$ kill -1 1247
Op√ß√£o:

$ kill -s SIGHUP 1247
Para fazer com que kill funcione de forma semelhante a pkill ou killall (evitando os comandos para descobrir os PIDs correspondentes), podemos usar a substitui√ß√£o de comandos:

$ kill -1 $(pgrep sleep)
Como voc√™ j√° deve saber, uma sintaxe alternativa √© kill -1 `pgrep sleep`.

Tip
Para uma lista exaustiva de todos os sinais de kill e seus c√≥digos, digite kill -l no terminal. Use -KILL (-9 ou -s KILL) para eliminar processos rebeldes quando todos os outros sinais falharem.



