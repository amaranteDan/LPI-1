Objetivo 102.1 Particionamento de Disco

Pense em um disco (ou dispositivo de armazenamento, já que os dispositivos modernos não contêm nenhum “disco”) como um “receptáculo físico” para seus dados.

Pontos de montagem
Isso significa vincular o sistema de arquivos a um ponto específico na árvore de diretórios do sistema, chamado ponto de montagem.

Quando montado, o conteúdo do sistema de arquivos estará disponível no ponto de montagem. Por exemplo, imagine que você tenha uma partição com os dados pessoais de seus usuários (o diretório pessoal deles), contendo os diretórios /john, /jack e /carol. Quando montados em /home, o conteúdo desses diretórios estará disponível em /home/john, /home/jack e /home/carol.

O ponto de montagem são diretorios associados com partições.

Tradicionalmente, todos os dispositivos externos eram montados no diretório /mnt. Ali existia uma série de pontos de ancoragem pré-configurados para os dispositivos mais comuns, como drives de CD-ROM (/mnt/cdrom) e de disquete (/mnt/floppy).

Ele foi substituído por /media, que agora é o ponto de montagem padrão para qualquer mídia removível (como discos externos, drives flash USB, leitores de cartão de memória, discos óticos etc.) conectada ao sistema.

Na maioria das distribuições Linux e ambientes de desktop modernos, os dispositivos removíveis são montados automaticamente em /media/USER/LABEL quando conectados ao sistema, sendo USER o nome de usuário e LABEL o nome do dispositivo. Por exemplo, um drive flash USB com o nome FlashDrive conectado pelo usuário john seria montado em /media/john/FlashDrive/. A maneira como isso é feito varia de acordo com o ambiente de desktop.

Dito isto, sempre que for preciso montar manualmente um sistema de arquivos, é recomendável montá-lo em /mnt. Os comandos específicos para controlar a montagem e desmontagem de sistemas de arquivos no Linux serão discutidos em outra lição.

A partição de inicialização (/boot)
A partição de inicialização contém arquivos usados pelo gerenciador de inicialização para carregar o sistema operacional. Nos sistemas Linux, o gerenciador de inicialização costuma ser o GRUB2 ou, em sistemas mais antigos, o GRUB Legacy. A partição geralmente é montada em /boot e seus arquivos são armazenados em /boot/grub.

Tecnicamente, uma partição de inicialização não é necessária, pois na maioria dos casos o GRUB pode montar a partição raiz (/) e carregar os arquivos a partir de um diretório /boot separado.

No entanto, uma partição de inicialização separada pode ser interessante, seja por segurança (garantindo que o sistema seja inicializado mesmo em caso de falha no sistema de arquivos raiz), ou se você desejar usar um sistema de arquivos que o carregador de inicialização não pode entender na partição raiz, ou se usar um método não suportado de criptografia ou compactação.

A partição de inicialização geralmente é a primeira partição no disco. Isso ocorre porque a IBM PC BIOS original endereçava os discos usando cilindros, cabeças e setores (CHS), com um máximo de 1024 cilindros, 256 cabeças e 63 setores, resultando em um tamanho máximo de disco de 528 MB (504 MB no MS-DOS). Isso significa que qualquer coisa além dessa marca não estaria acessível em sistemas legados, a menos que um esquema de endereçamento de disco diferente (como o Endereçamento de bloco lógico, LBA) fosse usado.

Portanto, para obter compatibilidade máxima, a partição de inicialização geralmente está localizada no início do disco e termina antes do cilindro 1024 (528 MB), garantindo que, aconteça o que acontecer, a máquina sempre poderá carregar o kernel.

Como a partição de inicialização armazena apenas os arquivos necessários para o carregador de inicialização, o disco RAM inicial e as imagens do kernel, ela pode ser bem pequena para os padrões atuais. Um bom tamanho é de cerca de 300 MB.

A partição do sistema EFI (ESP)
A partição do sistema EFI (ESP) é usada por máquinas baseadas na UEFI (Unified Extensible Firmware Interface) para armazenar gerenciadores de inicialização e imagens do kernel para os sistemas operacionais instalados.

Essa partição é formatada em um sistema de arquivos baseado em FAT. Em um disco particionado com uma tabela de partição GUID, ela possui o identificador global único C12A7328-F81F-11D2-BA4B-00A0C93EC93B. Se o disco tiver sido formatado no esquema de particionamento do MBR, o ID da partição será 0xEF.

Em máquinas com Microsoft Windows, essa partição geralmente é a primeira no disco, embora isso não seja obrigatório. O ESP é criado (ou preenchido) pelo sistema operacional após a instalação e, em um sistema Linux, é montado em /boot/efi.

A partição /home
Cada usuário do sistema possui um diretório inicial para armazenar arquivos pessoais e preferências. Aa maioria deles está localizada em /home. O diretório inicial costuma ter o mesmo nome que o usuário; assim, o usuário John teria seu diretório em /home/john.

Porém, há exceções. Por exemplo, o diretório inicial do usuário raiz é /root e alguns serviços do sistema podem ter usuários associados com diretórios pessoais em outros lugares.

Não existe uma regra para determinar o tamanho de uma partição para o diretório /home (a partição inicial). É preciso levar em consideração o número de usuários no sistema e como ele será usado. Um usuário que apenas navega na web e processa textos requer menos espaço do que um que trabalha com edição de vídeo, por exemplo.

Dados variáveis (/var)
Este diretório contém “dados variáveis”, ou arquivos e diretórios nos quais o sistema deve poder escrever durante a operação. Dentre eles estão os logs do sistema (em /var/log), os arquivos temporários (/var/tmp) e os dados de aplicativos em cache (em /var/cache).

/var/www/html também é o diretório padrão para os arquivos de dados do Apache Web Server e /var/lib/mysql é o local padrão para os arquivos de banco de dados do servidor MySQL. Porém, ambos podem ser alterados.

Uma boa razão para colocar /var em uma partição separada é a estabilidade. Muitos aplicativos e processos escrevem em /var e seus subdiretórios, como /var/log ou /var/tmp. Um processo defeituoso poderia escrever dados até que não restasse nenhum espaço livre no sistema de arquivos.

Se /var estiver em /, isso poderia disparar um pânico do kernel e corromper o sistema de arquivos, causando uma situação muito difícil de reverter. Mas se /var for mantido em uma partição separada, o sistema de arquivos raiz não será afetado.

Como no caso de /home, não existe uma regra universal para determinar o tamanho da partição de /var, já que isso vai variar conforme o uso que for feito do sistema. Em um sistema doméstico, uns poucos gigabytes devem bastar. Mas em um banco de dados ou servidor web, será necessário bem mais espaço. Nesse caso, seria melhor colocar /var em uma partição de um disco diferente da partição raiz, adicionando uma camada extra de proteção contra falhas físicas do disco.

Swap
A partição de troca (ou swap) é usada para passar as páginas de memória da RAM para o disco conforme necessário. Esta partição precisa ser de um tipo específico e configurada com um utilitário apropriado chamado mkswap antes de poder ser usada.

A partição de troca não pode ser montada como as outras, o que significa que não é possível acessá-la como um diretório normal e visualizar seu conteúdo.

Um sistema pode ter diversas partições de troca (embora isso seja incomum), e o Linux também suporta o uso de arquivos de troca em vez de partições, o que pode ser útil para aumentar rapidamente o espaço de troca quando necessário.

O tamanho da partição de troca é um tema controverso. A regra antiga dos primeiros dias do Linux (“duas vezes a quantidade de RAM”) nem sempre se aplica, dependendo de como o sistema está sendo usado e da quantidade de RAM física instalada.

Na documentação do Red Hat Enterprise Linux 7, a Red Hat recomenda o seguinte:

Quantidade de RAM	Tamanho de troca recomendado	Tamanho de troca recomendado com hibernação
< 2 GB de RAM

2x a quantidade de RAM

3x a quantidade de RAM

2-8 GB de RAM

Igual à quantidade de RAM

2x a quantidade de RAM

8-64 GB de RAM

No mínimo 4 GB

1.5x a quantidade de RAM

> 64 GB de RAM

No mínimo 4 GB

Não recomendado

Obviamente, a quantidade de troca pode depender da carga de trabalho. Se a máquina estiver executando um serviço crítico, como um banco de dados, servidor Web ou SAP, é aconselhável verificar o valor recomendado na documentação desses serviços (ou consultar o fornecedor do software).


LVM
Já discutimos como os discos são organizados em uma ou mais partições, com cada partição contendo um sistema de arquivos que descreve como os arquivos e os metadados associados são armazenados. Uma das desvantagens do particionamento é que o administrador do sistema deve decidir antecipadamente como o espaço em disco disponível em um dispositivo será distribuído. Isso pode ser problemático mais tarde, se uma partição exigir mais espaço do que o originalmente planejado. Claro que as partições podem ser redimensionadas, mas isso nem sempre é possível (se, por exemplo, não houver mais espaço livre no disco).

O Gerenciamento de Volumes Lógicos (LVM) é uma forma de virtualização do armazenamento que oferece aos administradores de sistema um método mais flexível do que o particionamento tradicional para gerenciar o espaço em disco. O objetivo do LVM é facilitar a gestão das necessidades de armazenamento de seus usuários finais. A unidade básica é o Volume Físico (PV), que é um dispositivo de bloco no sistema, como uma partição de disco ou uma matriz RAID.

Os PVs são agrupados em Grupos de Volumes (VG), que abstraem os dispositivos subjacentes e são vistos como um único dispositivo lógico, com a capacidade de armazenamento combinada dos PVs do componente.

Cada volume em um Grupo de Volumes é subdividido em partes de tamanho fixo chamadas extensões. As extensões em um PV são chamadas Extensões Físicas (PE), enquanto as do volume lógico são Extensões Lógicas (LE). De maneira geral, cada extensão lógica é mapeada para uma extensão física, mas isso pode mudar se forem usados recursos como o espelhamento de disco.

Os Grupos de Volumes podem ser subdivididos em Volumes Lógicos (LVs), com funcionalidade semelhante à das partições, mas com mais flexibilidade.

O tamanho de um Volume Lógico, conforme especificado durante a sua criação, é na verdade definido pelo tamanho das extensões físicas (por padrão, 4 MB) multiplicado pelo número de extensões no volume. Com isso, é fácil entender que para aumentar um Volume Lógico, por exemplo, basta adicionar mais extensões do pool disponível no Grupo de Volumes. Da mesma forma, as extensões podem ser removidas para reduzir o LV.

Após sua criação, um Volume Lógico é visto pelo sistema operacional como um dispositivo de bloco normal. Um dispositivo será criado em /dev, com o nome /dev/VGNAME/LVNAME, em que VGNAME é o nome do Grupo de Volumes e LVNAME o nome do Volume Lógico.

Esses dispositivos podem ser formatados com o sistema de arquivos desejado usando utilitários padrão (como o mkfs.ext4, por exemplo) e montados com os métodos usuais, seja manualmente, com o comando mount, ou automaticamente, adicionando-os ao arquivo /etc/fstab.

Exercícios Guiados
Nos sistemas Linux, onde são armazenados os arquivos do gerenciador de inicialização GRUB?

Onde deve estar a partição de inicialização para garantir que um PC seja capaz de carregar o kernel?

Onde a partição EFI costuma ser montada?

Normalmente, em qual diretório se monta manualmente um sistema de arquivos?

Exercícios Exploratórios
Qual a menor unidade dentro de um Grupo de Volumes?

Como se define o tamanho de um Volume Lógico?

Em um disco formatado com o esquema de particionamento MBR, qual a ID da Partição do Sistema EFI?

Além das partições de troca, como é possível aumentar rapidamente o espaço de troca em um sistema Linux?

Resumo
Nesta lição, falamos sobre particionamento e explicamos quais diretórios geralmente são mantidos em partições separadas e por quê. Além disso, demos uma visão geral do LVM (Gerenciamento Lógico de Volumes) e como ele pode oferecer uma maneira mais flexível de alocar os dados e o espaço em disco em comparação com o particionamento tradicional.

Os seguintes arquivos, termos e utilitários foram discutidos:

/
O sistema de arquivos raiz do Linux.

/var
O local padrão dos “dados variáveis”, ou seja, dados que podem encolher ou aumentar com o tempo.

/home
O diretório pai padrão para as pastas iniciais dos usuários regulares de um sistema.

/boot
O local padrão dos arquivos do gerenciador de inicialização, kernel do Linux e disco de RAM inicial.

Partição do Sistema EFI (ESP)
Usada pelos sistemas que têm UEFI implementada para o armazenamento dos arquivos de inicialização do sistema.

Espaço de troca
Usado para trocar páginas de memória do kernel quando a RAM está sendo muito solicitada.

Pontos de montagem
Locais em um diretório nos quais um dispositivo (como um disco rígido) será montado.

Partições
Divisões em um disco rígido.

Respostas aos Exercícios Guiados
Nos sistemas Linux, onde são armazenados os arquivos do gerenciador de inicialização GRUB?

Em /boot/grub.

Onde deve estar a partição de inicialização para garantir que um PC seja capaz de carregar o kernel?

Antes do cilindro 1024.

Onde a partição EFI costuma ser montada?

Em /boot/efi.

Normalmente, em qual diretório se monta manualmente um sistema de arquivos?

Em /mnt. Porém, isso não é obrigatório. Podemos montar uma partição no diretório que quisermos.

Respostas aos Exercícios Exploratórios
Qual a menor unidade dentro de um Grupo de Volumes?

Os Grupos de Volumes são subdivididos em extensões.

Como se define o tamanho de um Volume Lógico?

Pelo tamanho das extensões físicas multiplicado pelo número de extensões no volume.

Em um disco formatado com o esquema de particionamento MBR, qual a ID da Partição do Sistema EFI?

A ID é 0xEF.

Além das partições de troca, como é possível aumentar rapidamente o espaço de troca em um sistema Linux?

Podem ser usados arquivos de troca.

MSDOS

OBS: Discos SCSI maximo 15 partiçoes lógicas
Discos SATA - até 63 partições lógicas

Dispositivos IDE também considera CDROM ou unidades ZIP

Partição Primaria(Principal) - 1 - 4
Partição extendida (Partiçoes Secundarias) Só será possivel criar caso não seja utilizada todas partiçoes primarias.Não recebe dados
Partiçoes lógicas são criadas dentro das partiçoes extendidas 

Dispositivos IDE

Controladora			Dispositivo
Primaria -Master                /dev/hda
	 -Slave			/dev/hdb

Secundaria
	-Master			/dev/hdc
	-Slave			/dev/hdd


 Sistemas de arquivos

Ext2 - (Second extended File System) Não possui Journaling
Blocos do mesmo tamanho
Partição ate 4 TB
Até 255 caracteres por nome de arquivo;
5% para o root


Ext3 - possui journaling(log chamado journal)
Permite utilizar sistema de cotas
Blocos de 1,2 e 4 Kb;
Tamanho maximo 2TB.

Ext4 - Melhoria do Ext3, como tolerancia a falhas, desempenho, maior volume, maior numero de subdiretorios

Possui melhor desempenho
Alocação multipla
Journaling
Numero ilimitado de diretorios;
Tamanho maximo 16 TB.

Reiserfs - Nucleo baseado em arvore balanceada B+
Utiliza journaling;
blocos de 4Kb;
Tamanho maximo partição 1 EB.

Xfs - Sistema de arquivos com journaling otimizado para escalabilidade
Usado em sistemas com fibra optica e HD SCSI
Sucetivel a falhas de energia e consequente perda de dados;
Sistema de arquivos mais potente;
Journaling a um endereçamento de 64 bits;
Blocos de ate 64 bytes;
Tamanho maximo 32 bits = 16 TB / 64 bits 8,58 EB.


LVM - Logical Volume Management

Metodo para alocar espaço de disco rigidos em volumes logicos.
Facilidade de redimensionar;
Suporte ao LVM deve ser compilado no kernel.

Id da partição 8e (Linux LVM)

VG: Volume Group
PV: Phisical Volume
LV: Logical Volume
PE: Phisical Extent
LE: Logical Extent

Criando Volume Group(Grupo de Volume)
-Criar primeiro o Volume fisico
Ex:# pvcreate /dev/sdb1
   # pvcreate /dev/sdb2	
-Criando o grupo de volume
# vgcreate system  /dev/sdb1 /dev/sdb2
-s especifica uma tamanho PE diferente de 4MB

Ex: vgcreate system -s 2 /dev/sdb1.

Fazendo a ativação para uso.
#vgchange -a y system

Mostrando as informações do VG criado
#vgdisplay system
#vgs

Especificando o tamanho do volume
#lvcreate -l "total_disponivel" system
#lvcreate -L 1GB system  - Definindo um tamanho

Exibindo o volume logico disponivel no sistema
#lvs
#lvdisplay
OBS: -l usa o tamanho total
     -L usa o tamnaho especificado

Localização dentro do sistema de arquivos.
/dev: /dev/system/lvol0, /dev/system/lvol1.

Com os lV prontos, formatar usando #mkfs.

***Extendendo Grupo de Volume
#vgextend system /dev/hde1

#lvextend -L +50MB /dev/storage/dados
*sempre desmontar o sistema de arquivos.

*Reduzir o volume logico
#lvreduce -L 180M /dev/storage/dados

*Removendo Volumes lógicos
#lvremove -v /dev/storage/temp

*Removendo volumes fisicos
1 - Carregar o pvmove

#modprobe dm-mirror
#vgreduce storage /dev/loop0

*Renomear volumes logicos
#lvrename /dev/storage/dados /dev/storage/data

*Renomear o Grupo de volume
#lvchange -an storage - desabilita todos os volumes logicos

#vgrename storage local

Pontos de Montagem
/bin - Binarios
/boot - Arquivos do boot, incluido o kernel, arquivo initrd, pasta EFI, utilizado na BIOS pelo UEFI.
/dev - Dispositivos gerais. Gerenciado pelo daemon udev, que cuida da configuração dos dispositivos como teclado, mouse. monitor, discos rigidos, pendrives.
/etc - Arquivos de configuração
/home - Arquivo onde aramazena arquivos pessoais do usuario.
/lib - Diretorio de bibliotecas, dependencias dos binarios en /bin e /sbin
/media - Diretorio de montagem das partiçoes para usb e cdrom
/mnt - Ponto de montagem temporaria para copia de arquivos e etc.
/opt - Area de armazenamento generico para programas que não sao 100% compativeis com a estrutura de diretorios do linux.
/proc - Sistemas de arquivo virtual onde coleta informações do hardware e kernel. Aqui é possivel ver informações da memoria, cpu, parametros do kernel.
/run - Arquivos utilizados pelo processo runtime, pricipalmente para o boot.
/sbin - Arquivos do super binario, como o fsck, dump2fs, debugfs. Utilizado no modo de recuperação do sistema.
/srv - Serviços com FTP, APACHE, SAMBA
/sys - Informações do kernel, dispositivos e drivers.
/usr - A maior estrutura do linux. Contem binarios, documentação, imagens utilizadas pelo sistema. Somente-leitura. Evitar gravações. Partição separada. Local base para 
compilação do kernel. Aumento da segurança.
/var - Arquivos variaveis, como logs, cache, spool de impressão. Colocar em uma partição separada.
/tmp - Diretorio para montagem temporario. Gravar como noexec. Partição separada é considerada boa pratica.

Pergunta de Prova.
As partiçoes  /etc, /bin, /sbin, não devem ser montados em partiçoes diferentes da /. 

UEFI - Unified Extensible Firmware Interface
Projeto INtel boot
Gerenciamento de firmware de maneira consolidada
Segurança para o gerenciamento do boot
Suporte a essa tecnologia a partir do kernel 2.6
Acesso a interfaces graficas da inicialização
suporte a IPV6
Bios apenas carrega a MBR do primeiro HD, onde fica o gerenciador de boot
Aumenta da eficiencia da inicialização
Secure boot, impedindo programas afetem o pre boot
Suporte a GPT
UEFI tem um boot mais rapido
Inclusão de capacidades nativas como gerenciamento de hardware, suporte a rede, banco de dados e utilitarios em ambiente pré-OS
Modulo CSM - Compatibility Support Module que permite a emulação de um sistema BIOS-MBR permitindo que sistemas legados possam ser executados em hardware UEFI da classe3, que são UEFI nativos.

Para usar o UEFI
Disco de 64 bits
Validar versões do Linux que podem usar o UEFI
Padrãoo UEFI usa partições FAT12, FAT16, FAT32 - Similar ao stage2 do Grub
Durante o boot, o GRUB vai buscar a initrd e a vmlinuz no /boot

Verificar e Criar partição UEFI

[ -d /sys/firmware/efi } && echo "EFI boot on HDD" || echo "Legacy boot on HDD"

Verificar /etc/fstab se tem uma partição UEFI /boot /efi

Instalar o boot UEFI
sudo apt install grub-efi

Monte a partição EFI sobre o diretorio /boot Ex /dev/sda6
#mount /dev/sda6 /boot

Instalar gestor do boot

sudo gurb-install /dev/sda --target=x86_64-efi --efi-directory=/boot

Verificando com o comando #efibootmgr

Mudar ordem de boot # efibootmgr -o <bootnum>

Deletando uma entrada boot
#efibootmgr -b <bootnum> -B

Ativar entrada
#efibootmgr <bootnum> -a
-a = ativa
-A = desativa

Secure boot - A função é evitar que drivers e loaders não autorizados sejam executados, criando falhas de segurança, exploradas por malwares do tipo bootkit.
Como funciona. No boot seguro, permite um chave PKI po chave PK (Platform Key) seja gravada.
Após, o boot secure entra em modo user. Apenas drivers e loaders asinados por chaves KEK(Key Exchange Key) são carregadas.
Ou pode ser colocado em modo CUSTOM, onde chaves publicas adicionais são incluidas. MOK (Machine OWNER Keys), certificando os programas seguros.
Chaves KEK são certificadas X509 ou RSA 2048, ou usando um hash SHA-256 presente em DB e sem assinatura presente DBX.
Banco  de dados na NVRAM do firmware.
DB Banco de Assinaturas
DBX Banco de assinaturas proibidas, onde drivers que contem nesse banco tem sua execução NEGADA.


****Objetivo 102.2 Instalar um gerenciador de Boot
GRUB Legacy e GRUB 2
A versão original do GRUB (Grand Unified Bootloader), agora conhecida como GRUB Legacy, foi desenvolvida em 1995 como parte do projeto GNU Hurd e, mais tarde, adotada como o gerenciador de inicialização padrão de muitas distribuições Linux, substituindo alternativas anteriores, como o LILO.

O GRUB 2 é uma remodelagem completa do GRUB com o objetivo de deixá-lo mais limpo, seguro, robusto e poderoso. Dentre as muitas vantagens em relação ao GRUB Legacy estão um arquivo de configuração muito mais flexível (com mais comandos e instruções condicionais, semelhantes a uma linguagem de script), um design mais modular e melhor localização/internacionalização.

Também há suporte para temas e menus gráficos de inicialização com telas de abertura, a possibilidade de inicializar ISOs LiveCD diretamente a partir do disco rígido, melhor suporte para arquiteturas não-x86, suporte universal para UUIDs (facilitando a identificação de discos e partições) e muito mais.

O GRUB Legacy não está mais em desenvolvimento ativo (a última versão foi a 0.97, em 2005), e hoje a maioria das principais distribuições Linux vem com o GRUB 2 como gerenciador de inicialização padrão. No entanto, ainda podemos encontrar sistemas usando o GRUB Legacy; portanto, é importante saber como usá-lo e em que ele difere do GRUB 2.

Onde fica o gerenciador de inicialização?
Historicamente, os discos rígidos nos sistemas compatíveis com IBM PC eram particionados usando o esquema de particionamento MBR, criado em 1982 para o IBM PC-DOS (MS-DOS) 2.0.

Nesse esquema, o primeiro setor de 512 bytes do disco é chamado de Master Boot Record (Registro Mestre de Inicialização, em português) e contém uma tabela que descreve as partições no disco (a tabela de partições) e também um código de inicialização (bootstrap), chamado gerenciador de inicialização.

Quando o computador é ligado, esse código mínimo (devido às restrições de tamanho) do gerenciador de inicialização é carregado, executado e transfere o controle para um carregador de inicialização secundário no disco, geralmente localizado em um espaço de 32 KB entre o MBR e a primeira partição, que por sua vez carregará o(s) sistema(s) operacional(is).

Em um disco particionado em MBR, o código de inicialização do GRUB é instalado no MBR. Ele carrega e transfere o controle para uma imagem “núcleo” instalada entre o MBR e a primeira partição. A partir desse ponto, o GRUB é capaz de carregar o restante dos recursos necessários (definições de menu, arquivos de configuração e módulos extras) do disco.

No entanto, o MBR tem limitações no número de partições (originalmente, no máximo 4 partições primárias; mais tarde, no máximo 3 partições primárias com 1 partição estendida, subdividida em uma série de partições lógicas) e no tamanho máximo de disco (2 TB). Para suplantar essas limitações, foi criado um novo esquema de particionamento chamado GPT (GUID Partition Table), parte do padrão UEFI (Unified Extensible Firmware Interface).

Os discos particionados em GPT podem ser usados em computadores com a BIOS tradicional do PC ou com o firmware UEFI. Em máquinas com BIOS, a segunda parte do GRUB é armazenada em uma partição especial de inicialização da BIOS.

Em sistemas com firmware UEFI, o GRUB é carregado pelo firmware a partir dos arquivos grubia32.efi (para sistemas de 32 bits) ou grubx64.efi (para sistemas de 64 bits) em uma partição chamada ESP (EFI System Partition)

GRUB2 - GRand Unified Bootloader

Stage1 - Primeiro setores do dispositivo de Boot. Carregar o essential do bootloader. Usa os 446 bytes. 
Stage 1.5 Sera usado caso o stage1 nao consiga iniciar toda a inicialização. /boot/grub
Stage2 - Ultima etapa. Lê o /boot/grub/menu.lst. Caso não consiga, será exibido o prompt de comando do GRUB
              |------> partição (de 0 a 3) partiçoes primarias  
No grub. (hd0,1)       partição (de 4 em diante) partições extendidas
           |
           |-------Hard disk(0) Inicia no zero

Ex: (hd0,1) Primeiro disco, na segunda primaria

Ex: (hd1,5) Segundo disco, na segunda partição extendida.


Arquivo de consulta do GRUB 
/boot/grub/menu.lst

**2 parametros para dar atenção
default: Define a entrada de inicialização padrão
timeout: define o tempo limite para que a entrada de inicialização seja selecionada.

Arquivo grub.conf

Configuração de interface do menu Grub é /boot/grub/grub.conf

***Instalando o Grub

Verificar se existe o arquivo /boot/grub
Ou copiar o diretorio /usr/lib/grub/i386-pc. Algumas distribuiçoes limpam essa arquivo caso o grub não seja o bootloader padrão.

Fazendo backup
# dd if=/dev/sda of=/boot/MBR-bkp.bin bs=512 count=1

Retornando backup
# dd if/boot/MBR-bkp.bin of=/dev/sda bs=512 count=1

Em seguida, gravando o grub

***Conteúdo da partição de inicialização

O conteúdo da partição /boot pode variar de acordo com a arquitetura do sistema ou o gerenciador de inicialização usado, mas em um sistema baseado em x86 geralmente encontramos os arquivos abaixo. A maioria deles recebe o sufixo -VERSION, onde -VERSION é a versão correspondente do kernel do Linux. Assim, por exemplo, o arquivo de configuração para a versão do kernel do Linux 4.15.0-65-generic seria chamado de config-4.15.0-65-generic.

Arquivo de configuração
Este arquivo, geralmente chamado config-VERSION (veja o exemplo acima), armazena parâmetros de configuração para o kernel do Linux. Este arquivo é gerado automaticamente quando um novo kernel é compilado ou instalado e não deve ser diretamente modificado pelo usuário.

Mapa do sistema
Este arquivo é uma tabela de consulta que articula nomes de símbolos (como variáveis ou funções) com sua posição correspondente na memória. Isso é útil ao se corrigir um tipo de falha do sistema conhecida como kernel panic (pânico do kernel), pois permite ao usuário saber qual variável ou função estava sendo chamada quando ocorreu a falha. Como no caso do arquivo de configuração, o nome geralmente é System.map-VERSION (por exemplo, System.map-4.15.0-65-generic).

Kernel do Linux
Este é o kernel do sistema operacional propriamente dito. Seu nome é geralmente vmlinux-VERSION (por exemplo, vmlinux-4.15.0-65-generic). Também se pode encontrar o nome vmlinuz em vez de vmlinux — o z no final indica que o arquivo foi compactado.

Disco RAM inicial
Geralmente se chama initrd.img-VERSION e contém um sistema de arquivos raiz mínimo carregado em um disco RAM, contendo os utilitários e módulos de kernel necessários para que o kernel possa montar o sistema de arquivos raiz real.

Arquivos relacionados ao gerenciador de inicialização
Em sistemas com o GRUB instalado, eles costumam estar localizados em /boot/grub e incluem o arquivo de configuração (/boot/grub/grub.cfg para o GRUB 2 ou /boot/grub/menu.lst no caso do GRUB Legacy), módulos (em /boot/grub/i386-pc), arquivos de tradução (em /boot/grub/locale) e fontes (em /boot/grub/fonts) do GRUB.



#grub-install /dev/sda

ou
#grub-install '(hd0)'

Verificando /grub/device.map

#cat /boot/grub/device.map

***Parametros para o GRUB
>root (hd0,2)
> kernel (hd0,2) /boot/vmlinuz-4.0.19 vga=769 quiet
>boot

GRUB 2
Instalando o GRUB 2
O GRUB 2 pode ser instalado usando o utilitário grub-install. Se seu sistema se recusa a inicializar, você precisará inicializá-lo usando um Live CD ou um disco de recuperação, descobrir qual é a partição de inicialização do seu sistema, montá-la e executar o utilitário.

Note
Para usar os comandos abaixo, é preciso estar logado como root. Se não for o caso, execute primeiro sudo su - para “virar” root. No final, digite exit para se deslogar e voltar a ser um usuário comum.

O primeiro disco de um sistema é geralmente o dispositivo de inicialização . Pode ser necessário saber se existe uma partição de inicialização no disco. Para isso existe o utilitário fdisk. Para listar todas as partições no primeiro disco da sua máquina, use:

# fdisk -l /dev/sda
Disk /dev/sda: 111,8 GiB, 120034123776 bytes, 234441648 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x97f8fef5

Device     Boot    Start       End   Sectors   Size Id Type
/dev/sda1  *        2048   2000895   1998848   976M 83 Linux
/dev/sda2        2002942 234440703 232437762 110,9G  5 Extended
/dev/sda5        2002944  18008063  16005120   7,6G 82 Linux swap / Solaris
/dev/sda6       18010112 234440703 216430592 103,2G 83 Linux
A partição de inicialização é identificada com o * na coluna boot. No exemplo acima, ela é /dev/sda1.

A seguir, crie um diretório temporário em /mnt e monte a partição nele:

# mkdir /mnt/tmp
# mount /dev/sda1 /mnt/tmp
Depois execute grub-install, apontando-o para o dispositivo de inicialização (não a partição) e o diretório em que a partição de inicialização está montada. Se o sistema possuir uma partição de inicialização dedicada, o comando será:

# grub-install --boot-directory=/mnt/tmp /dev/sda1
Caso esteja instalando em um sistema que não possui uma partição de inicialização, mas apenas um diretório /boot no sistema de arquivos raiz, aponte-o em grub-install. Nesse caso, o comando é:

# grub-install --boot-directory=/boot /dev/sda1
Configurando o GRUB 2
O arquivo de configuração padrão do GRUB 2 é /boot/grub/grub.cfg. Esse arquivo é gerado automaticamente e não se recomenda editá-lo à mão. Para fazer alterações na configuração do GRUB, é preciso editar o arquivo /etc/default/grub e depois executar o utilitário update-grub para gerar um arquivo compatível.

Note
update-grub normalmente é um atalho para grub-mkconfig -o /boot/grub/grub.cfg, de modo que eles produzem os mesmos resultados.

Existem algumas opções no arquivo /etc/default/grub para controlar o comportamento do GRUB 2, como o kernel padrão de inicialização, tempo limite, parâmetros extras da linha de comando, etc. Os mais importantes são:

GRUB_DEFAULT=
A entrada de menu padrão para a inicialização. Pode ser um valor numérico (como 0, 1, etc.), o nome de um item de menu (como debian) ou saved, que é usado em conjunto com GRUB_SAVEDEFAULT=, explicado abaixo. Lembre-se de que as entradas de menu começam com zero, de forma que a primeira é 0, a segunda é 1 e assim por diante.

GRUB_SAVEDEFAULT=
Se esta opção estiver definida como true e GRUB_DEFAULT= como saved, a opção padrão de inicialização sempre será a última selecionada no menu de inicialização.

GRUB_TIMEOUT=
O tempo limite, em segundos, para que a entrada do menu padrão seja selecionada. Se definido como 0, o sistema inicializará a entrada padrão sem exibir um menu. Se definido como -1, o sistema aguardará até que o usuário selecione uma opção, não importa quanto tempo leve.

GRUB_CMDLINE_LINUX=
Lista as opções de linha de comando que serão adicionadas às entradas do kernel do Linux.

GRUB_CMDLINE_LINUX_DEFAULT=
Por padrão, duas entradas de menu são geradas para cada kernel do Linux, uma com as opções padrão e uma entrada para recuperação. Com esta opção, você pode incluir parâmetros extras que serão adicionados apenas à entrada padrão.

GRUB_ENABLE_CRYPTODISK=
Se definido como y, comandos como grub-mkconfig, update-grub e grub-install procuram por discos criptografados e adicionam os comandos necessários para acessá-los durante a inicialização. Assim, a inicialização automática é desabilitada (GRUB_TIMEOUT= com valor diferente de -1) porque uma senha será exigida para descriptografar os discos antes que possam ser acessados.

Administrando as entradas de menu
Quando rodamos o update-grub, o GRUB 2 busca por kernels e sistemas operacionais na máquina e gera as entradas de menu correspondentes no arquivo /boot/grub/grub.cfg. É possível adicionar novas entradas manualmente aos arquivos de script dentro do diretório /etc/grub.d.

Esses arquivos devem ser executáveis e são processados em ordem numérica pelo update-grub. Portanto, 05_debian_theme é processado antes de 10_linux e assim por diante. As entradas de menu personalizadas são geralmente adicionadas ao arquivo 40_custom.

A sintaxe básica de uma entrada de menu é mostrada abaixo:

menuentry "Default OS" {
    set root=(hd0,1)
    linux /vmlinuz root=/dev/sda1 ro quiet splash
    initrd /initrd.img
}
A primeira linha sempre começa com menuentry e termina com {. O texto entre aspas será mostrado como o rótulo da entrada no menu de inicialização do GRUB 2.

O parâmetro set root define o disco e a partição em que o sistema de arquivos raiz do sistema operacional está localizado. Note que no GRUB 2 os discos são numerados a partir de zero, então hd0 é o primeiro disco (sda no Linux), hd1 o segundo e assim por diante. As partições, por sua vez, são numeradas a partir de um. No exemplo acima, o sistema de arquivos raiz está localizado no primeiro disco (hd0), primeira partição (,1) ou sda1.

Em vez de especificar diretamente o dispositivo e a partição, também podemos pedir que o GRUB 2 busque por um sistema de arquivos com um rótulo ou UUID (Universally Unique Identifier) específico. Para isso, use o parâmetro search --set=root seguido por --label e o rótulo do sistema de arquivos a buscar, ou --fs-uuid seguido pelo UUID do sistema de arquivos.

Use o comando abaixo para encontrar o UUID de um sistema de arquivos:

$ ls -l /dev/disk/by-uuid/
total 0
lrwxrwxrwx 1 root root 10 nov  4 08:40 3e0b34e2-949c-43f2-90b0-25454ac1595d -> ../../sda5
lrwxrwxrwx 1 root root 10 nov  4 08:40 428e35ee-5ad5-4dcb-adca-539aba6c2d84 -> ../../sda6
lrwxrwxrwx 1 root root 10 nov  5 19:10 56C11DCC5D2E1334 -> ../../sdb1
lrwxrwxrwx 1 root root 10 nov  4 08:40 ae71b214-0aec-48e8-80b2-090b6986b625 -> ../../sda1
No exemplo acima, o UUID de /dev/sda1 é ae71b214-0aec-48e8-80b2-090b6986b625. Se quisermos defini-lo como dispositivo raiz do GRUB 2, o comando seria:
 search --set=root --fs-uuid ae71b214-0aec-48e8-80b2-090b6986b625.

Ao usar o comando search, é comum adicionar o parâmetro --no-floppy para que o GRUB não perca tempo buscando em disquetes.

A linha linux indica onde está localizado o kernel do sistema operacional (neste caso, o arquivo vmlinuz na raiz do sistema de arquivos). Depois disso, podemos passar parâmetros na linha de comando para o kernel.

No exemplo acima, especificamos a partição root (root=/dev/sda1) e passamos três parâmetros do kernel: a partição root deve ser montada com acesso apenas de leitura (ro), a maioria das mensagens de log deve ser desabilitada (quiet) e uma tela de boas-vindas deve ser exibida (splash).

A linha initrd indica onde está localizado o disco de RAM inicial. No exemplo acima, o arquivo é initrd.img, localizado na raiz do sistema de arquivos.

Note
A maioria das distribuições Linux não coloca de fato o kernel e o initrd no diretório raiz do sistema de arquivos raiz. Em vez disso, esses são links para os arquivos reais dentro do diretório ou partição /boot.

A última linha de uma entrada do menu deve conter apenas o caractere }.


Arquivo de consulta do GRUB2
/boot/grub/grub.cfg em alguns casos /etc/grub2
Stage 1.5 foi eliminado

Arquivo de configuração
/etc/default/grub

Configurações avançadas
/et/grub.d/

Partições começam com 1

Instalar o grub

#grub-install /dev/sda

Sistemas UEFI
# grub-install --efi-directory=/boot/efi --bootloader-id=Linux - Criada entrada de boot na NVRAM do UEFI 
# efibootmgr necessita estar instalado
# partição ESP montada /boot/efi
Apos, o GRUB le o arquivo /biit/grub/grub.cfg

Configurações Personalizada /boot/grub/grub.cfg

menuentry "Linux Personalizado"{
  linux /boot/vmlinuz root=/dev/sad2 rw
  initrd /boot/initramfs.img	
}

linux = indicada caminho para o kernel e seus parametros e a partição raiz
initrd indica a imagem initrd

chainloader - Bootloader alternativo
cryptomount - Partição cripografada, fica disponivel para o Grub
source - Executa o conteudo de outro arquivo de configuração dentro do mesmo grub
insmod - Carrega um modulo. Ex lvm, mod, ntfs.mod, btrfs.mod

***Arquivo de alterações do grub
/etc/default/grub - A partir daui é gerado o /boot/grub/grub.cfg

***Conhecendo alguns arquivos

GRUB_DEFAULT - O sistema iniciado por padrão. Inicia no 0

GRUB_SAVEDEFAULT - Caso definido como true, usa o ultimo item alterado como saved.

GRUB_HIDDEN_TIMEOUT - Quantos segundos aguardar sem mostrar o menu do Grub

GRUB_HIDDEN_TIMEOUT_QUIET - Se true, o contador para chamar o grub não é exibido

GRUB_TIMEOUT - Tempo para exibir o menu grub

GRUB_DISTRIBUTOR - Nome descritivo do item

*GRUB_CMDLINE_LINUX - Linha essencial para parametros do kernel(cmdline). Tanto para o modo normal como para recuperação.

GRUB_CMDLINE_LINUX_DEFAULT - Linha de parametros para o kernel(cmdline) modo normal.

GRUB_DISABLE_LINUX_UUID - Se true, não localiza dispositivos por UUID.

GRUB GFXMODE - Resolução de Tela. Ex 1024X768. Profundidade da caro 1024X768X16, 1024X768X24

GRUB_DISABLE_LINUX_RECOVERY - Se true, não exibe opção de recuperação.

GRUB_INIT_TUNE - Tocar som no speaker interno do menu GRUB

GRUB_DISBLE_OS_PROBER - Descarta a busca automatica por outros sistemas operacionais.

***Após qualquer alteração no /etc/default/grub grub.cfg  rodar os comandos.
update-grub se não disponivel
grub-mkconfig -o /boot/grub/grub.cfg ou
grub2-mkconfig -o /boot/grub/grub.cfg

Inicialização a partir do shell do GRUB 2
Podemos usar o shell do GRUB 2 para inicializar o sistema caso uma configuração incorreta em uma entrada de menu cause uma falha de inicialização.

A primeira coisa que você deve fazer é descobrir onde está a partição de inicialização. Use para isso o comando ls, que mostra uma lista das partições e discos encontrados pelo GRUB 2.

grub> ls
(proc) (hd0) (hd0,msdos1)
No exemplo acima, tudo é simples. Existe apenas um disco (hd0), com apenas uma partição: (hd0,msdos1).

Os discos e partições listados serão diferentes no seu sistema. Em nosso exemplo, a primeira partição do hd0 é chamada msdos1 porque o disco foi particionado usando o esquema de particionamento MBR. Se ele fosse particionado usando GPT, o nome seria gpt1.

Para inicializar o Linux, precisamos de um kernel e de um disco RAM inicial (initrd). Vamos verificar o conteúdo de (hd0,msdos1):

grub> ls (hd0,msdos1)/
lost+found/ swapfile etc/ media/ bin/ boot/ dev/ home/ lib/ lib64/ mnt/ opt/ proc/ root/ run/ sbin/ srv/ sys/ tmp/ usr/ var/ initrd.img initrd.img.old vmlinuz cdrom/
Podemos adicionar o parâmetro -l a ls para obter uma lista longa, como faríamos em um terminal Linux. Use Tab para completar automaticamente os nomes de discos, partições e arquivos.

Note que temos as imagens do kernel (vmlinuz) e initrd (initrd.img) bem no diretório raiz. Se não, poderíamos conferir o conteúdo de /boot com list (hd0,msdos1)/boot/.

Agora, defina a partição de inicialização:

grub> set root=(hd0,msdos1)
Carregue o kernel do Linux com o comando linux, seguido pelo caminho para o kernel e pela opção root= para informar ao kernel onde está localizado o sistema de arquivos raiz do sistema operacional.

grub> linux /vmlinuz root=/dev/sda1
Carregue o disco RAM inicial com initrd, seguido pelo caminho completo para o arquivo initrd.img:

grub> initrd /initrd.img
Agora, inicialize o sistema com boot.

Inicializando com o shell de resgate
No caso de uma falha na inicialização, o GRUB 2 pode carregar um shell de resgate, uma versão simplificada do shell que mencionamos anteriormente. Você o reconhecerá pelo prompt de comando, que é exibido como grub rescue>.

O processo para inicializar um sistema a partir deste shell é quase idêntico ao mostrado anteriormente. No entanto, será preciso carregar alguns módulos do GRUB 2 para fazer as coisas funcionarem.

Depois de descobrir qual é a partição de inicialização (com ls, como mostrado anteriormente), use o comando set prefix=, seguido pelo caminho completo para o diretório que contém os arquivos do GRUB 2 — geralmente /boot/grub. No nosso exemplo:

grub rescue> set prefix=(hd0,msdos1)/boot/grub
Em seguida, carregue os módulos normal e linux com o comando insmod:

grub rescue> insmod normal
grub rescue> insmod linux
A seguir, defina a partição de inicialização com set root= como ensinado anteriormente, carregue o kernel do linux (com linux), o disco RAM inicial (initrd) e tente inicializar com boot.

GRUB Legacy
Instalando o GRUB Legacy a partir de um sistema em execução
Para instalar o GRUB Legacy em um disco a partir de um sistema em execução, empregaremos o utilitário grub-install. O comando básico é grub-install DEVICE, onde DEVICE é o disco no qual você deseja instalar o GRUB Legacy. Um exemplo seria /dev/sda.

# grub-install /dev/sda
Note que é preciso especificar o dispositivo no qual o GRUB Legacy será instalado, como /dev/sda/, não a partição como em /dev/sda1.

Por padrão, o GRUB copia os arquivos necessários para o diretório /boot no dispositivo especificado. Se você deseja copiá-los para outro diretório, use o parâmetro --boot-directory= seguido pelo caminho completo para o local onde os arquivos devem ser copiados.

Instalando o GRUB Legacy a partir de um shell do GRUB
Se você não conseguir inicializar o sistema por algum motivo e precisar reinstalar o GRUB Legacy, poderá fazê-lo no shell do GRUB em um disco de inicialização do GRUB Legacy.

No shell do GRUB (digite c no menu de inicialização para acessar o prompt grub>), o primeiro passo é configurar o dispositivo de inicialização, que contém o diretório /boot. Por exemplo, se esse diretório estiver na primeira partição do primeiro disco, o comando seria:

grub> root (hd0,0)
Se você não souber qual dispositivo contém o diretório /boot, peça ao GRUB para procurá-lo com o comando find, como abaixo:

grub> find /boot/grub/stage1
 (hd0,0)
Em seguida, defina a partição de inicialização conforme as instruções acima e use o comando setup para instalar o GRUB Legacy no MBR e copiar os arquivos necessários no disco:

grub> setup (hd0)
Ao final, reinicie o sistema e ele deverá inicializar normalmente.

Definindo entradas e configurações do menu do GRUB Legacy
As entradas de menu e configurações do GRUB Legacy são armazenadas no arquivo /boot/grub/menu.lst. Trata-se de uma lista de comandos e parâmetros em um arquivo de texto simples, que pode ser editado diretamente em seu editor de texto predileto.

As linhas que começam com # são consideradas comentários e as linhas em branco são ignoradas.

Uma entrada de menu possui ao menos três comandos. O primeiro, title, define o título do sistema operacional na tela do menu. O segundo, root, informa ao GRUB Legacy qual o dispositivo ou partição de inicialização.

A terceira entrada, kernel, especifica o caminho completo para a imagem do kernel que deve ser carregada quando a entrada correspondente for selecionada. Observe que esse caminho é relativo ao dispositivo especificado no parâmetro root.

Veja um exemplo simples a seguir:

# This line is a comment
title My Linux Distribution
root (hd0,0)
kernel /vmlinuz root=/dev/hda1
Ao contrário do GRUB 2, no GRUB Legacy tanto as partições quanto os discos são numerados a partir de zero. Portanto, o comando root (hd0,0) define a partição de inicialização como a primeira partição (0) do primeiro disco (hd0).

Podemos omitir a instrução root se especificarmos o dispositivo de inicialização antes do caminho no comando kernel. A sintaxe é a mesma, portanto:

kernel (hd0,0)/vmlinuz root=dev/hda1
equivale a:

root (hd0,0)
kernel /vmlinuz root=/dev/hda1
Ambos carregam o arquivo vmlinuz a partir do diretório root (/) da primeira partição do primeiro disco (hd0,0).

O parâmetro root=/dev/hda1 após o comando kernel informa ao kernel do Linux qual partição deve ser usada como sistema de arquivos raiz. Este é um parâmetro do kernel do Linux, não um comando do GRUB Legacy.

Note
Para saber mais sobre os parâmetros do kernel, visite https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html.

Pode ser necessário especificar o local da imagem inicial do disco RAM para o sistema operacional com o parâmetro initrd. O caminho completo para o arquivo pode ser especificado como no parâmetro kernel, mas também é possível especificar um dispositivo ou partição antes do caminho, como por exemplo:

# This line is a comment
title My Linux Distribution
root (hd0,0)
kernel /vmlinuz root=/dev/hda1
initrd /initrd.img
O GRUB Legacy tem um design modular, no qual módulos (geralmente armazenados como arquivos .mod em /boot/grub/i386-pc) podem ser carregados para adicionar recursos extras, como suporte a hardware incomum, sistemas de arquivos ou novos algoritmos de compactação.

Os módulos são carregados usando o comando module, seguido pelo caminho completo para o arquivo .mod correspondente. Lembre-se de que, como no caso dos kernels e imagens initrd, esse caminho é relativo ao dispositivo especificado no comando root.

O exemplo abaixo carrega o módulo 915resolution, necessário para definir corretamente a resolução da memória de imagens (frame buffer) em sistemas com chipsets de vídeo das séries Intel 800 ou 900.

module /boot/grub/i386-pc/915resolution.mod
Carregamento em cadeia de outros sistemas operacionais
O GRUB Legacy pode ser usado para carregar sistemas operacionais não suportados, como o Windows, usando um processo chamado de carregamento em cadeia (chainloading). O GRUB Legacy é carregado primeiro e, quando a opção correspondente é selecionada, o gerenciador de inicialização do sistema desejado é carregado.

Uma entrada típica para o carregamento em cadeia do Windows seria semelhante a esta:

# Load Windows
title Windows XP
root (hd0,1)
makeactive
chainload +1
boot
Vamos esclarecer cada parâmetro. Como anteriormente, root (hd0,1) especifica o dispositivo e a partição em que o gerenciador de inicialização do sistema operacional que queremos carregar está localizado. Neste exemplo, a segunda partição do primeiro disco.

makeactive
define um sinalizador indicando que esta é uma partição ativa. Funciona apenas em partições primárias do DOS.

chainload +1
diz ao GRUB para carregar o primeiro setor da partição de inicialização. É nela que costumam ficar os gerenciadores de inicialização.

boot
executa o gerenciador de inicialização e carrega o sistema operacional correspondente.

***Recuperando o Grub

>linux (hd1,2)/vmlinuz root=/dev/sda4
>initrd (hd1,2)/initramfs.img
>boot

***Fazendo backup da MBR
dd =if/dev/hda of=mbr.backup bs=512 count=1

***Restaurando backup

dd if=mbr.backup of=/dev/hda

***Realizando a leitura do arquivo /etc/fstab

# /etc/fstab: static file system information.
#
#
# <file system> <mount point>                            <type>  <options>       <dump>  <pass>
# /             /dev/sda3 
UUID=923a359e-b4b1-4d62-bc54-194ef54faacc /               ext4   errors=remount-ro 0       1

# /boot        /dev/sda1 
UUID=ccbb56ac-0bc9-4432-97db-e7ef888cc9ec /boot           ext4    defaults        0       2

# /var        /dev/sda5
UUID=7f74f184-23c0-4715-94b3-42310d9c8875 /var            ext4    defaults        0       2

# swap       /dev/sda6 
UUID=0a29a596-3668-415a-982a-b7df2ef40284 none            swap    sw              0       0

/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

Respostas aos Exercícios Guiados
Qual é o local padrão do arquivo de configuração do GRUB 2?

/boot/grub/grub.cfg

Quais são as etapas necessárias para alterar as configurações do GRUB 2?

Efetuar as alterações no arquivo /etc/default/grub, depois atualizar a configuração com update-grub.

Em qual arquivo devem ser adicionadas as entradas de menu personalizadas do GRUB 2?

/etc/grub.d/40_custom

Onde são armazenadas as entradas de menu do GRUB Legacy?

/boot/grub/menu.lst

Como podemos entrar no shell do GRUB a partir de um menu do GRUB 2 ou GRUB Legacy?

Pressionando c na tela de menu.

Respostas aos Exercícios Exploratórios
Imagine um usuário configurando o GRUB Legacy para inicializar a partir da segunda partição do primeiro disco. Ele escreve a seguinte entrada de menu personalizada:

title My Linux Distro
root (hd0,2)
kernel /vmlinuz root=/dev/hda1
initrd /initrd.img
No entanto, o sistema não inicializa. O que está errado?

A partição de inicialização está incorreta. Lembre-se de que, ao contrário do GRUB 2, o GRUB Legacy conta as partições a partir de zero. Portanto, o comando correto para a segunda partição do primeiro disco seria root (hd0,1).

Imagine que você tenha um disco identificado como /dev/sda com diversas partições. Que comando pode ser usado para descobrir qual a partição de inicialização em um sistema?

Use fdisk -l /dev/sda. A partição de inicialização estará marcada na lista com um asterisco (*).

Qual o comando para descobrir o UUID de uma partição?

Use ls -la /dev/disk/by-uuid/ e procure pelo UUID que aponta para a partição.

Considere a seguinte entrada para o GRUB 2

menuentry "Default OS" {
    set root=(hd0,1)
    linux /vmlinuz root=/dev/sda1 ro quiet splash
    initrd /initrd.img
}
Altere-a para que o sistema inicialize a partir de um disco com o UUID 5dda0af3-c995-481a-a6f3-46dcd3b6998d

Será preciso alterar a declaração set root. Em vez de especificar um disco e uma partição, diga ao GRUB para buscar pela partição com o UUID desejado.

menuentry "Default OS" {
    search --set=root --fs-uuid 5dda0af3-c995-481a-a6f3-46dcd3b6998d
    linux /vmlinuz root=/dev/sda1 ro quiet splash
    initrd /initrd.img
}
Como configurar o GRUB 2 para aguardar 10 segundos antes de inicializar a entrada de menu padrão?

Adicionando o parâmetro GRUB_TIMEOUT=10 a /etc/default/grub.

Em um shell do GRUB Legacy, quais são os comandos para instalar o GRUB na primeira partição do segundo disco?

grub> root (hd1,0)
grub> setup (hd1)

***102.3 Controle das bibliotecas compartilhadas

Bibliotecas de ligação estática - Sã bibliotecas ligas ao programa em tempo de execução.
Bibliotecas ligação dinamica - Bibliotecas cuja ligação ocorre sob demanda.

As libs tem uma S.O (Shared Object)


O caminho da biblioteca é configurado no diretório /etc, especificamente no arquivo /etc/ld.so.conf e, o que atualmente é mais comum, nos arquivos do diretório /etc/ld.so.conf.d. Normalmente, o primeiro inclui uma única linha include para os arquivos *.conf do segundo:

$ cat /etc/ld.so.conf
include /etc/ld.so.conf.d/*.conf
O diretório /etc/ld.so.conf.d contém arquivos *.conf:

$ ls /etc/ld.so.conf.d/
libc.conf  x86_64-linux-gnu.conf

Diretorio das libs

/lib     Bibliotecas usadas por programas e na inicialização
/lib32
/usr/lib Bibliotecas usada por programas do sistema geral
/usr/local/lib - Bibliotecas usadas por programas que não são parte do sistema.


***Usando o ldconfig. 
Usado para configurar as ligações em tempo de execução do link dinâmico. Cria sonames como link simbolicos. Atualiza o cache /etc/ld.so.conf

O comando ldconfig trata de ler esses arquivos de configuração, criando o conjunto de links simbólicos anteriormente mencionados que ajudam a localizar as bibliotecas individuais, e, por fim, de atualizar o arquivo de cache /etc/ld.so.cache. Assim, o ldconfig deve ser executado sempre que atualizarmos ou adicionarmos arquivos de configuração.




#ldconfig -v - Verboso
#ldconfig -p Print cache

Saida do comando ldconfig -p | grep -i ssh


	libssh2.so.1 (libc6,x86-64) => /lib/x86_64-linux-gnu/libssh2.so.1
	libssh.so.4 (libc6,x86-64) => /lib/x86_64-linux-gnu/libssh.so.4
	libssh-gcrypt.so.4 (libc6,x86-64) => /lib/x86_64-linux-gnu/libssh-gcrypt.so.4

Obs: caso seja apgado o /etc/ld.so.conf rodar o ldconfig par atualizar o cache

Atenção. Distribuições do Red Hat não costuma incluir /usr/local/lib no /etc/ld.so.conf.
Assim é necessario adicionar manualmente o caminho /usr/local/lib no /etc/ld.so.conf

***Variaveis de Ambiente
LD_LIBRARY_PATH - Contem lista de diretorios separados por ponto e virgula

LD_PRELOAD - Mesma função /etc/ld.so.preload. Bibliotecas de sobreposição

LD_DEBUG - Bibliotecas usadas por desenvolvedores

***Identificando bibliotecas compartilhadas.

Ex: ldd /usr/bin/vi



	linux-vdso.so.1 (0x00007ffff07b0000)
	libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f43f9ef9000)
	libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f43f9eca000)
	libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f43f9e9e000)
	libcanberra.so.0 => /lib/x86_64-linux-gnu/libcanberra.so.0 (0x00007f43f9e8a000)
	libacl.so.1 => /lib/x86_64-linux-gnu/libacl.so.1 (0x00007f43f9e7f000)
	libgpm.so.2 => /lib/x86_64-linux-gnu/libgpm.so.2 (0x00007f43f9e77000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f43f9e6f000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f43f9caa000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f43fa35c000)
	libpcre2-8.so.0 => /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f43f9c1a000)
	libvorbisfile.so.3 => /lib/x86_64-linux-gnu/libvorbisfile.so.3 (0x00007f43f9c0f000)
	libtdb.so.1 => /lib/x86_64-linux-gnu/libtdb.so.1 (0x00007f43f9bf6000)
	libltdl.so.7 => /lib/x86_64-linux-gnu/libltdl.so.7 (0x00007f43f9beb000)
	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f43f9bc7000)
	libvorbis.so.0 => /lib/x86_64-linux-gnu/libvorbis.so.0 (0x00007f43f9b9a000)
	libogg.so.0 => /lib/x86_64-linux-gnu/libogg.so.0 (0x00007f43f9991000)


2 Ex: ldd /usr/bin/ssh

	linux-vdso.so.1 (0x00007ffc345d0000)
	libcrypto.so.1.1 => /lib/x86_64-linux-gnu/libcrypto.so.1.1 (0x00007f9ad8193000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f9ad818d000)
	libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f9ad8170000)
	libresolv.so.2 => /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f9ad8156000)
	libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f9ad812a000)
	libgssapi_krb5.so.2 => /lib/x86_64-linux-gnu/libgssapi_krb5.so.2 (0x00007f9ad80dd000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9ad7f16000)
	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f9ad7ef4000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f9ad855e000)
	libpcre2-8.so.0 => /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f9ad7e64000)
	libkrb5.so.3 => /lib/x86_64-linux-gnu/libkrb5.so.3 (0x00007f9ad7d85000)
	libk5crypto.so.3 => /lib/x86_64-linux-gnu/libk5crypto.so.3 (0x00007f9ad7d55000)
	libcom_err.so.2 => /lib/x86_64-linux-gnu/libcom_err.so.2 (0x00007f9ad7d4f000)
	libkrb5support.so.0 => /lib/x86_64-linux-gnu/libkrb5support.so.0 (0x00007f9ad7d3e000)
	libkeyutils.so.1 => /lib/x86_64-linux-gnu/libkeyutils.so.1 (0x00007f9ad7d37000)

Localização das bibliotecas

o ld.so localiza o /etc/ld.so.cache
*Diretorios /lib /usr/lib em sistemas 32 bits

/usr/lib64 e /li64 em sistemas 64 Bits

Bibliotecas adicionais
/etc/ld.so.conf

o ldconfig altera /etc/ld.so.conf e atualiza o /etc/ld.so.cache



Exportando um biblioteca para ser carregada pela ld.so

ex: export LD_LIBRARY_PATH=caminho_da_biblioteca - acesso temporário

Em seguida podemos verificar o valor:

$ echo $LD_LIBRARY_PATH
/usr/local/mylib
Para adicionar /usr/local/mylib ao caminho da biblioteca na sessão atual do shell e exportá-lo para todos os processos secundários originados desse shell, escreveríamos:

$ export LD_LIBRARY_PATH=/usr/local/mylib
Para remover a variável de ambiente LD_LIBRARY_PATH, basta digitar:

$ unset LD_LIBRARY_PATH
Se quiser tornar as alterações permanentes, escrevemos a linha

export LD_LIBRARY_PATH=/usr/local/mylib
Em um dos scripts de inicialização do Bash, como /etc/bash.bashrc ou ~/.bashrc.


Buscando pelas dependências de um executável específico
Para buscar as bibliotecas compartilhadas requeridas por um programa específico, use o comando ldd seguido do caminho absoluto para o programa. A saída mostra o caminho do arquivo da biblioteca compartilhada, bem como o endereço de memória hexadecimal no qual ele é carregado:

# ldd /usr/bin/git
        linux-vdso.so.1 (0x00007ffd4c857000)
        libpcre2-8.so.0 => /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007fc157e70000)
        libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007fc157e53000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fc157e31000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc157c6c000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fc158286000)

Da mesma forma, usamos ldd para procurar as dependências de um objeto compartilhado:

$ ldd /lib/x86_64-linux-gnu/libc.so.6
	/lib64/ld-linux-x86-64.so.2 (0x00007fbfed578000)
	linux-vdso.so.1 (0x00007fffb7bf5000)


Com a opção -u (ou --unused), o ldd imprime as dependências diretas não utilizadas (se existirem):

$ ldd -u /usr/bin/git
Unused direct dependencies:
	/lib/x86_64-linux-gnu/libz.so.1
	/lib/x86_64-linux-gnu/libpthread.so.0
	/lib/x86_64-linux-gnu/librt.so.1
A razão para haver dependências não utilizadas está relacionada às opções usadas pelo vinculador ao criar o binário. Embora o programa não precise de uma biblioteca não utilizada, ela ainda estava vinculada e rotulada como NEEDED (necessária) nas informações sobre o arquivo-objeto. Para investigar isso, podemos usar comandos como readelf ou objdump, que serão necessários mais adiante, nos exercícios exploratórios.

Você desenvolveu um programa e deseja adicionar um novo diretório de biblioteca compartilhada em seu sistema (/opt/lib/mylib). Você escreve o caminho absoluto em um arquivo chamado mylib.conf.

Em que diretório deve ser armazenado esse arquivo?

/etc/ld.so.conf.d

Qual comando deve ser executado para que as alterações sejam totalmente efetivas?

ldconfig

Qual comando você usaria para listar as bibliotecas compartilhadas exigidas por kill?

ldd /bin/kill

Respostas aos Exercícios Exploratórios
objdump é um utilitário de linha de comando que exibe informações sobre arquivos objeto. Confira se ele está instalado em seu sistema com which objdump. Se não estiver, instale-o agora.

Use objdump com -p (ou --private-headers) e grep para exibir as dependências de glibc:

objdump -p /lib/x86_64-linux-gnu/libc.so.6 | grep NEEDED

# which objdump
/usr/bin/objdump

# objdump -p /lib/x86_64-linux-gnu/libc.so.6

/lib/x86_64-linux-gnu/libc.so.6:     file format elf64-x86-64

Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000000040 paddr 0x0000000000000040 align 2**3
         filesz 0x00000000000002a0 memsz 0x00000000000002a0 flags r--
  INTERP off    0x0000000000193f00 vaddr 0x0000000000193f00 paddr 0x0000000000193f00 align 2**4
         filesz 0x000000000000001c memsz 0x000000000000001c flags r--
    LOAD off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**12
         filesz 0x0000000000024980 memsz 0x0000000000024980 flags r--
    LOAD off    0x0000000000025000 vaddr 0x0000000000025000 paddr 0x0000000000025000 align 2**12
         filesz 0x000000000014a43c memsz 0x000000000014a43c flags r-x
    LOAD off    0x0000000000170000 vaddr 0x0000000000170000 paddr 0x0000000000170000 align 2**12
         filesz 0x0000000000049fab memsz 0x0000000000049fab flags r--

Use objdump com -p (ou --private-headers) e grep para exibir o soname de glibc:

objdump -p /lib/x86_64-linux-gnu/libc.so.6 | grep SONAME

Use objdump com -p (ou --private-headers) e grep para exibir as dependências do Bash:

objdump -p /bin/bash | grep NEEDED


***102.4 Gerenciamento de Pacotes Debian

#Repositorio Debian

Gerenciamento de Pacotes Debian.

DPKG - Gerenciamento de pacotes individuais

apt-get busca repositorios remotos
apt agrega funçoes extras ao apt-get

Repositorio -> /etc/apt/sources.list/
	      /etc/apt/sources.list.d/

Exemplo de pacote binario:
deb http://ftp.br.debia.org/debian wheezy main contrib non-free
--------------------------------|    |    -------------------- categoria
localização 			|    Versao
				

*Atualizar repositorios

apt-get update ou apt update

*Adicionar cdrom como repositorio
apt-cdrom add
apt-cdrom -d /home/kov /meucdrom add -> Exemplo.

*Instalação de pacotes
-y indica sim para todas as perguntas

apt-cache search pacote -> procura o pacote
apt search pacote

apt-get install pacote -> instala pacotes
apt install pacote

*Instalar pacotes individuais.
dpkg -i pacote.deb (.deb para pacotes binarios) ou caso o pacote esteja instalado, ele atualiza.
dpkg -I google-chrome-stable_current_amd64.deb -Traz informações sobre o pacote
dpkg install pacote.deb

apt-get install -f (força a instalaçao de dependencia)

#Reconfigurando um pacote

dpkg-reconfigure pacote
apt-get --reinstall install pacote

ex dpkg-reconfigure tzdata

apt reinstall pacote

*Removendo pacotes

apt-get remove pacote

dpkg -r pacote
dpkg -p pacote (-p de purge: remove arquivos de configuração)

apt-get remove --purge pacote

*Atualizando pacotes

apt-get upgrade pacote

*Atualizando todos os pacotes

apt-get upgrade
apt safe-upgrade

apt-get -u lista pacotes desatualizados

apt-get dist-upgrade atualizando todos os pacotes e substitui todos os obsoletos

*Inspecionando pacotes

dpkg -l pacote -> mostra estado dos pacotes

# dpkg -l apache2
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name           Version      Architecture Description
+++-==============-============-============-=================================
ii  apache2        2.4.46-1     amd64        Apache HTTP Server


dpkg -S procura qual pacote instalou o arquivo

# dpkg -S xzcat                                                                                                                                                   
xz-utils: /usr/share/man/man1/xzcat.1.gz
xz-utils: /usr/bin/xzcat



Descobrindo qual pacote possui um arquivo específico
Às vezes, podemos precisar descobrir qual pacote possui um arquivo específico no sistema. Para isso, usamos o utilitário dpkg-query, seguido pelo parâmetro` -S` e o caminho para o arquivo em questão:

# dpkg-query -S /usr/bin/unrar-nonfree
unrar: /usr/bin/unrar-nonfree


dpkg -L lista arquivos instalados pelo pacote

dpkg --contents pacote.deb lista o conteudo do pacote

apt-cache search - A saida será uma lista de todos os pacotes que contem o padrão, seja no nome do pacote, descrição ou nos arquivos conhecidos.
apt search

apt-cache show pacote - Mostra informações completas do pacote, incluido descriçao
apt show

Ex:
# apt-cache show git
Package: git
Version: 1:2.30.2-1
Installed-Size: 35058
Maintainer: Jonathan Nieder <jrnieder@gmail.com>
Architecture: amd64
Replaces: git-core (<< 1:1.7.0.4-1.), gitweb (<< 1:1.7.4~rc1)
Provides: git-completion, git-core
Depends: libc6 (>= 2.28), libcurl3-gnutls (>= 7.56.1), libexpat1 (>= 2.0.1), libpcre2-8-0 (>= 10.22), zlib1g (>= 1:1.2.0), perl, liberror-perl, git-man (>> 1:2.30.2), git-man (<< 1:2.30.2-.)
Recommends: ca-certificates, patch, less, ssh-client
Suggests: gettext-base, git-daemon-run | git-daemon-sysvinit, git-doc, git-el, git-email, git-gui, gitk, gitweb, git-cvs, git-mediawiki, git-svn
Breaks: bash-completion (<< 1:1.90-1), cogito (<= 0.18.2+), dgit (<< 5.1~), git-buildpackage (<< 0.6.5), git-core (<< 1:1.7.0.4-1.), gitosis (<< 0.2+20090917-7), gitpkg (<< 0.15), gitweb (<< 1:1.7.4~rc1), guilt (<< 0.33), openssh-client (<< 1:6.8), stgit (<< 0.15), stgit-contrib (<< 0.15)
Size: 5527496
SHA256: 1efbc55de3ca1211fe4c0afc559f2edbded30ed3095d94dd602311bf604b3fd7
SHA1: a3b1de53d57ea9cabb3cf3753f1df2847934faeb
MD5sum: 927610ac33981f208f76cc71046ca2e1


dpkg -p pacote

*Limpando repositorios
 -> /var/cache/apt/archives (diretorio de cache dos repositorios)

A cache local
Quando instalamos ou atualizamos um pacote, o arquivo .deb correspondente é baixado em um diretório de cache local antes do pacote ser instalado. Por padrão, esse diretório é /var/cache/apt/archives. Os arquivos parcialmente baixados são copiados para /var/cache/apt/archives/partial/.

Conforme instalamos e atualizamos diferentes pacotes, o diretório da cache pode ficar bastante volumoso. Para recuperar espaço, podemos esvaziar a cache usando o comando apt-get clean. Ele remove o conteúdo dos diretórios /var/cache/apt/archives e /var/cache/apt/archives/partial/.

apt-get clean
apt-get autoclean
apt autoremove

*Estatisticas dos pacotes

apt-cache stats

* Conhecimento Geral

apt install -d pacote faz download do pacote sem instalar (caso de verificação)

*Resolvendo dependencias

Corrigindo dependências quebradas
É possível ter “dependências quebradas” em um sistema. O termo significa que um ou mais dos pacotes instalados dependem de outros pacotes que não foram instalados ou não estão mais presentes. Isso pode ocorrer devido a um erro do APT ou a um pacote instalado manualmente.

Para resolver o problema, use o comando apt-get install -f. Ele procura “consertar” os pacotes quebrados instalando as dependências ausentes, garantindo que todos os pacotes voltem a ficar consistentes.

Tip
Você também pode usar apt install -f.

apt install --fix-missing
apt update --fix-missing  ou apt update -f missing


Os seguintes comandos foram abordados:

dpkg -i
Instala um único pacote ou uma lista de pacotes separados por espaço.

dpkg -r
Remove um pacote ou uma lista de pacotes separados por espaço.

dpkg -I
Inspeciona um pacote, fornecendo detalhes sobre o software instalado e todas as dependências necessárias.

dpkg --get-selections
Lista todos os pacotes que o dpkg instalou no sistema.

dpkg -L
Imprime uma lista de todos os arquivos instalados por um pacote específico.

dpkg-query
Com um nome de arquivo especificado, este comando imprimirá o pacote que instalou o arquivo.

dpkg-reconfigure
Este comando re-executa um script pós-instalação de pacotes para que um administrador possa fazer ajustes de configuração da instalação do pacote.

apt-get update
Este comando atualiza o índice do pacote local de acordo com o que está disponível nos repositórios configurados no diretório /etc/apt/.

apt-get install
Este comando baixa um pacote de um repositório remoto e o instala junto com suas dependências. Também pode ser usado para instalar um pacote Debian que já foi baixado.

apt-get remove
Este comando desinstala o(s) pacote(s) especificado(s) do sistema.

apt-cache show
Assim como o comando dpkg -I, pode ser usado para exibir os detalhes de um pacote específico.

apt-cache search
Este comando procura um pacote específico no banco de dados em cache local do APT.

apt-file update
Este comando atualiza o cache do pacote para que o apt-file possa consultar seu conteúdo.

apt-file search
Este comando procura em qual pacote um arquivo está incluído. Uma lista de todos os pacotes que contêm o padrão é retornada.

apt-file list
Este comando é usado para listar o conteúdo de um pacote, assim como o comando dpkg -L.

****Respostas aos Exercícios Guiados
Qual seria o comando para instalar um pacote chamado package.deb usando dpkg?

Passe o parâmetro -i para o dpkg:

# dpkg -i package.deb
Usando dpkg-query, descubra qual pacote contém um arquivo chamado 7zr.1.gz.

Adicione o parâmetro -S a dpkg-query:

# dpkg-query -S 7zr.1.gz
É possível remover um pacote chamado unzip do sistema usando dpkg -r unzip se o pacote file-roller depender dele? Se não, qual seria o jeito correto de fazer isso?

Não. O dpkg não resolve dependências e não permite remover um pacote se outro pacote instalado depender dele. Neste exemplo, podemos primeiro remover file-roller (pressupondo que nada depende dele) e em seguida remover unzip, ou remover os dois ao mesmo tempo com

# dpkg -r unzip file-roller
Usando o utilitário apt-file, como podemos descobrir qual pacote contém o arquivo /usr/bin/unrar?

Use o parâmetro search seguido pelo caminho (ou nome de arquivo):

# apt-file search /usr/bin/unrar
Usando o apt-cache, qual seria o comando para exibir informações para o pacote gimp?

Use o parâmetro show seguido pelo nome do pacote:

# apt-cache show gimp


Respostas aos Exercícios Exploratórios
Considere um repositório com pacotes de fontes Debian para a distribuição xenial, hospedado em http://us.archive.ubuntu.com/ubuntu/ e com pacotes para o componente universe. Qual seria a linha correspondente a adicionar a /etc/apt/sources.list?

Os pacotes fonte são do tipo deb-src, então a linha deve ser:

deb-src http://us.archive.ubuntu.com/ubuntu/ xenial universe
Essa linha também poderia ser adicionada a um arquivo .list fem /etc/apt/sources.list.d/. Ela pode ter qualquer nome, mas é melhor que seja descritivo, algo como xenial_sources.list.

Ao compilar um programa, aparece uma mensagem de erro reclamando que o arquivo de cabeçalho zzip-io.h não está presente no seu sistema. Como você pode descobrir qual pacote fornece esse arquivo?

Use apt-file search para descobrir qual pacote contém um arquivo que não está presente no sistema:

# apt-file search zzip-io.h
Como podemos ignorar um aviso de dependência e remover um pacote usando dpkg, mesmo que haja pacotes que dependam dele no sistema?

O parâmetro --force poderia ser usado, mas isso jamais deve ser feito a menos que se saiba exatamente o que se está fazendo, já que existe um risco enorme de que o sistema seja deixado em um estado inconsistente ou “quebrado”.

Como é possível pode obter mais informações sobre um pacote chamado midori usando apt?

Use apt-cache show seguido pelo nome do pacote:

# apt-cache show midori
Antes de instalar ou atualizar pacotes com o apt, qual comando deve ser usado para garantir que o índice do pacote esteja atualizado?

apt-get update deve ser usado. Ele baixa os índices mais recentes do pacote dos repositórios descritos no arquivo /etc/apt/sources.list ou no diretório /etc/apt/sources.list.d/.

Fonte de pesquisa: https://learning.lpi.org/pt/learning-materials/101-500/102/102.5/102.5_01/


****102.5 Gerenciamento de Pacotes YUM/RPM

***Instalando pacotes

Obs: o rpm não gerencia dependencias. Nestes casos o yum, dnf e zypper fazem essa função.


rpm -ivh nome_do_pacote.rpm

-i --install - instalar

-U --update - Atualiza e instala caso ja exista um pacote instalado

Ex: rpm -Uvh pacote.rpm
ou rpm -ivh --replacepkgs pacote.rpm -Vai instalar em cima do que esta, mesmo sendo a mesma versão.

rpm -ivh --replacefiles pacote.rpm - Instala mesmo sendo o pacote antigo

rpm -uvh --oldpackages pacote.rpm
****
Banco de dados do rpm redhat-rpmdb --redhatprovides

-F --freshen - Atualiza
rpm -Fvh *.rpm

-V --verify - Verifica arquivos criados na instalação.
rpm -Vf /bin/vi - Pesquisa pacote proprietario do arquivo

-e --erase - Desinstala um pacote
rpm -e pacote

-q ou --query Inspeciona pacotes

***Comando rpm com sub-opções

rpm -qa ou rpm --query --all  Consulta todos os  pacotes instalados

rpm -qc pacote ou rpm --query --configfiles - Lista arquivos de configuração do pacote

rpm -qd pacote ou rpm --query --docfiles - Lista a documentação do pacote

rpm -qf caminho_do_arquivo ou rpm --query --file caminho_do_arquivo - Informações sobre qual pacote instalou o arquivo
# rpm -qf /usr/bin/unzip
unzip-6.0-19.el7.x86_64

rpm -qi nome_do_pacote ou rpm --query --info nomedopacote - Informação sobre o pacote, versão etc

rpm -qip pacote Traz uma lista dos arquivos de um pacote que ainda não foi instalado 

rpm -ql nomedopacote ou rpm --query --list nomedopacote -Lista os arquivos dentro do pacote

rpm -qlp pacote.rpm

rpm -qp pacote.rpm ou rpm --query --package pacote.rpm - Faz a inspeção de um pacote não instalado.

rpm -qR nomedopacote ou rpm --query -requires nomedopacote - Mostra pacotes necessarios(dependencias) para o pacote indicado

rpm --query --whatrequires nomedopacote - Lista quais programas dependem do pacote

***Subopções

rpm -qpR pacote.rpm - Para mostrar dependencias

as opçoes --nodeps e --force devem ser usadas com cautela. Pode causar efeitos indesejados nos progrmas em funcionamento

--test pode ser usado para saber qual será o resultado de uma instalação.

***Verificar todos os pacotes instalados

rpm -Va

Verificar pacote instalado sobre um arquivo

rpm -Vp pacote.rpm

***Importar a chave GPG da redHat

rpm --import /usr/share/rhn/RPM-GPG-KEY

***Exibir a lista das chaves importadas

rpm -qa gpg-pubkey*

***Exibindo detalhes de uma chave

rpm -qi gpg-pubkey-d77777888-uyuyuy

***Verificar um assinatura do pacote

rpm -k --nogpg pacote

rpm -K arquivo.rpm


***YUM 

yum check-update - Verificando de pacotes disponiveis para atualização.

***Atualizando pacote unico
yum update glibc


yum update - Atualiza todos os pacotes e dependencias

***Listando pacotes

yum list all - Pacotes disponiveis para instalação

yum list installed - Lista de pacotes instalados

yum list available - Lista pacotes candidatos para instalação

yum grupolist - Lista de grupo de pacotes conhecidos

yum repolist - Identifica respositorio 

***Obs: Ao listar pacotes é possivel usar caracteres coringa. Não esquecer de escapar

Ex yum lista available gimp\*plugin\*

yum list installed "krb?-*"

***Pesquisando pacotes

yum search meld kompare - Yum search usado quando não se sabe exatamente o nome do pacote

yum info abrt - Busca informação do pacote 

Dica

É possivelbuscar informação de mais de um pacote no mesmo comando. Ex yum info foo bar

***Instalando pacotes com YUM

yum install pacote

ou Multiplos

yum install pacote outro_pacote


***Verificando se pacote tem determinado arquivo

yum install /usr/bin/named

Usando coringa

yum provides "*bin/named"


Para saber quais pacotes proveem determinados arquivos.

yum whatprovides /etc/hosts


yum provides ou
yum whatprovides

***INstalando grupo de pacotes

yum -v grouplist kde\*

ou
yum groupinstall kde-desktop

ou
yum install @kde-desktop

***Desinstalando pacotes

yum remove pacote

yum groupremove "KDE (K Desktop Environment) - Removendo grupo de pacotes

ou 
yum groupremove kde-desktop

ou
yum remove @kde-desktop

***Yumdownloader - Utilitario que permite fazer download dos arquivos rpm a partir de repositorios YUM e salvar local

Ex yumdownloader --dstdir /tmp/pacote --resolve foo




Configurando o YUM

/etc/yum.conf centro de configuração do YUM
/etc/yum.repos.d - repositorio

Administrando os repositórios de software
Para o yum, os “repos” estão listados no diretório /etc/yum.repos.d/. Cada repositório é representado por um arquivo .repo, como CentOS-Base.repo.

Repositórios adicionais podem ser incluídos pelo usuário acrescentando um arquivo .repo no diretório mencionado acima, ou no final de /etc/yum.conf. No entanto, a maneira recomendada de adicionar ou gerenciar repositórios é usar a ferramenta yum-config-manager.

Para adicionar um repositório, use o parâmetro --add-repo, seguido da URL para um arquivo .repo.

# yum-config-manager --add-repo https://rpms.remirepo.net/enterprise/remi.repo
Loaded plugins: fastestmirror, langpacks
adding repo from: https://rpms.remirepo.net/enterprise/remi.repo
grabbing file https://rpms.remirepo.net/enterprise/remi.repo to /etc/yum.repos.d/remi.repo
repo saved to /etc/yum.repos.d/remi.repo
Para obter uma lista de todos os repositórios disponíveis, use yum repolist all. A saída obtida será semelhante a esta:

# yum repolist all
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirror.ufscar.br
 * epel: mirror.globo.com
 * extras: mirror.ufscar.br
 * updates: mirror.ufscar.br
repo id                       repo name                    status
updates/7/x86_64              CentOS-7 - Updates           enabled:  2,500
updates-source/7              CentOS-7 - Updates Sources   disabled
Os repositórios disabled (desabilitados) serão ignorados ao instalar ou atualizar o software. Para habilitar ou desabilitar um repositório, use o utilitário yum-config-manager, seguido pelo ID do repositório.

Na saída acima, a identidade do repositório é mostrada na primeira coluna (repo id) de cada linha. Usamos apenas a parte anterior ao primeiro /, de forma que o id do repositório CentOS-7 - Updates é updates, e não updates/7/x86_64.

# yum-config-manager --disable updates
O comando acima desabilita o repositório updates. Para reativá-lo, use:

# yum-config-manager --enable updates
***Plugins do yum

yum info yum - Consultando os plugins

*** Limpando o cache que armazena os pacotes baixados

local /var/cache/yum

yum clean packages -Para excluir pacotes baixados e metadatas
yum clean metadata


***Desabilitando o plugn em tempo de execução

yum update --disableplugin=presto


***DNF - Gerenciador de pacotes que instala, atualiza e remove pacotes rpm.

O dnf, a ferramenta de gerenciamento de pacotes usada no Fedora, é um fork do yum. Como tal, muitos dos comandos e parâmetros são semelhantes. Esta seção oferece apenas uma visão geral rápida do dnf.

Busca de pacotes
dnf search PATTERN, onde PATTERN é aquilo que você está buscando. Por exemplo, dnf search unzip mostra todos os pacotes que contêm a palavra unzip no nome ou descrição.

Obter informações sobre um pacote
dnf info PACKAGENAME

Instalar pacotes
dnf install PACKAGENAME, onde PACKAGENAME é o nome do pacote que se deseja instalar. Para encontrar o nome, faça uma busca.

Remover pacotes
dnf remove PACKAGENAME

Atualizar pacotes
dnf upgrade PACKAGENAME para atualizar um só pacote. Omita o nome do pacote para atualizar todos os pacotes do sistema.

Descobrir qual pacote fornece um arquivo específico
dnf provides FILENAME

Obter uma lista de todos os pacotes instalados no sistema
dnf list --installed

Listar o conteúdo de um pacote
dnf repoquery -l PACKAGENAME

Note
O dnf tem um sistema de ajuda embutido que mostra mais informações (como parâmetros extras) para cada comando. Para usá-lo, digite dnf help seguido pelo comando, como dnf help install.

dnf repolist Para lista repositorios

dnf repolist enabled ou disabled Exibe a lista de repositorios ativados ou desativados


Para adicionar um repositório, use dnf config-manager --add_repo URL, onde URL é a URL completa do repositório. Para habilitar um repositório, use dnf config-manager --set-enabled REPO_ID.

Da mesma forma, para desativar um repositório, use dnf config-manager --set-disabled REPO_ID. Nos dois casos, REPO_ID é o ID exclusivo do repositório, que pode ser obtido com dnf repolist. Os repositórios adicionados são ativados por padrão. Os repositórios são armazenados em arquivos .repo no diretório /etc/yum.repos.d/, com exatamente a mesma sintaxe usada para o yum.

Zypper
O zypper é a ferramenta de gerenciamento de pacotes usada no SUSE Linux e OpenSUSE. Em termos de recursos, é semelhante ao apt e ao yum, sendo capaz de instalar, atualizar e remover pacotes de um sistema, com resolução automática de dependências.

Atualizando o índice do pacote
A exemplo de outras ferramentas de gerenciamento de pacotes, o zypper trabalha com repositórios que contêm pacotes e metadados. Esses metadados precisam ser atualizados periodicamente para que o utilitário fique a par dos pacotes mais recentes disponíveis. Para fazer uma atualização, basta digitar:

# zypper refresh
Repository 'Non-OSS Repository' is up to date.
Repository 'Main Repository' is up to date.
Repository 'Main Update Repository' is up to date.
Repository 'Update Repository (Non-Oss)' is up to date.
All repositories have been refreshed.
O zypper possui um recurso de atualização automática que pode ser ativado caso a caso, ou seja, alguns repositórios poderão ser atualizados automaticamente antes de uma consulta ou da instalação de um pacote, e outros poderão precisar ser atualizados manualmente. Vamos ensinar a controlar esse recurso em breve.

Buscando pacotes
Para procurar um pacote, use o operador search (ou se), seguido pelo nome do pacote:

# zypper se gnumeric
Loading repository data...
Reading installed packages...

S | Name           | Summary                           | Type
--+----------------+-----------------------------------+--------
  | gnumeric       | Spreadsheet Application           | package
  | gnumeric-devel | Spreadsheet Application           | package
  | gnumeric-doc   | Documentation files for Gnumeric  | package
  | gnumeric-lang  | Translations for package gnumeric | package
O operador de pesquisa também serve para obter uma lista de todos os pacotes instalados no sistema. Para isso, use o parâmetro -i sem o nome do pacote, como em zypper se -i.

Para ver se um pacote específico está instalado, adicione o nome do pacote ao comando acima. Por exemplo, o seguinte comando buscará dentre os pacotes instalados por um que contenha “firefox” no nome:

# zypper se -i firefox
Loading repository data...
Reading installed packages...

S | Name                               | Summary                 | Type
--+------------------------------------+-------------------------+--------
i | MozillaFirefox                     | Mozilla Firefox Web B-> | package
i | MozillaFirefox-branding-openSUSE   | openSUSE branding of -> | package
i | MozillaFirefox-translations-common | Common translations f-> | package

Para pesquisar apenas nos pacotes não-instalados, adicione o parâmetro -u ao operador se.

Instalando, atualizando e removendo pacotes
Para instalar um pacote de software, use o operador install (ou in), seguido pelo nome do pacote. Desta maneira:

# zypper in unrar
zypper in unrar
Loading repository data...
Reading installed packages...
Resolving package dependencies...

The following NEW package is going to be installed:
  unrar

1 new package to install.
Overall download size: 141.2 KiB. Already cached: 0 B. After the operation, additional 301.6 KiB will be used.
Continue? [y/n/v/...? shows all options] (y): y
Retrieving package unrar-5.7.5-lp151.1.1.x86_64
                                     (1/1), 141.2 KiB (301.6 KiB unpacked)
Retrieving: unrar-5.7.5-lp151.1.1.x86_64.rpm .......................[done]
Checking for file conflicts: .......................................[done]
(1/1) Installing: unrar-5.7.5-lp151.1.1.x86_64 .....................[done]

O zypper também pode ser usado para instalar um pacote RPM no disco enquanto tenta atender às dependências usando pacotes dos repositórios. Para isso, basta fornecer o caminho completo para o pacote em vez de apenas um nome de pacote, como em zypper in /home/john/newpackage.rpm.

Para atualizar os pacotes instalados no sistema, use zypper update. Como no caso do processo de instalação, aparece uma lista de pacotes a serem instalados/atualizados e o gerenciador pergunta se você deseja continuar.

Se quiser listar apenas as atualizações disponíveis, sem instalar nada, use zypper list-updates.

Para remover um pacote, use o operador remove (ou rm), seguido pelo nome do pacote:

# zypper rm unrar
Loading repository data...
Reading installed packages...
Resolving package dependencies...

The following package is going to be REMOVED:
  unrar

1 package to remove.
After the operation, 301.6 KiB will be freed.
Continue? [y/n/v/...? shows all options] (y): y
(1/1) Removing unrar-5.7.5-lp151.1.1.x86_64 ........................[done]
Lembre-se de que a remoção de um pacote também remove outros pacotes que dependem dele. Por exemplo:

# zypper rm libgimp-2_0-0
Loading repository data...
Warning: No repositories defined. Operating only with the installed resolvables. Nothing can be installed.
Reading installed packages...
Resolving package dependencies...

The following 6 packages are going to be REMOVED:
  gimp gimp-help gimp-lang gimp-plugins-python libgimp-2_0-0
  libgimpui-2_0-0

6 packages to remove.
After the operation, 98.0 MiB will be freed.
Continue? [y/n/v/...? shows all options] (y):
Descobrindo quais pacotes possuem um arquivo específico
Para ver quais pacotes contêm um arquivo específico, use o operador de pesquisa seguido pelo parâmetro --provides e o nome do arquivo (ou o caminho completo para ele). Por exemplo, para saber quais pacotes contêm o arquivo libgimpmodule-2.0.so.0 em `/usr/lib64/, usaríamos:

# zypper se --provides /usr/lib64/libgimpmodule-2.0.so.0
Loading repository data...
Reading installed packages...

S | Name          | Summary                                      | Type
--+---------------+----------------------------------------------+--------
i | libgimp-2_0-0 | The GNU Image Manipulation Program - Libra-> | package
Obtendo informações sobre um pacote
Para ver os metadados associados a um pacote, use o operador info seguido pelo nome do pacote. Serão exibidos o repositório de origem, nome do pacote, versão, arquitetura, fornecedor, tamanho instalado, se está instalado ou não, status (se está atualizado), o pacote de origem e uma descrição.

# zypper info gimp
Loading repository data...
Reading installed packages...

Information for package gimp:
 -----------------------------
Repository     : Main Repository
Name           : gimp
Version        : 2.8.22-lp151.4.6
Arch           : x86_64
Vendor         : openSUSE
Installed Size : 29.1 MiB
Installed      : Yes (automatically)
Status         : up-to-date
Source package : gimp-2.8.22-lp151.4.6.src
Summary        : The GNU Image Manipulation Program
Description    :
    The GIMP is an image composition and editing program, which can be
    used for creating logos and other graphics for Web pages. The GIMP
    offers many tools and filters, and provides a large image
    manipulation toolbox, including channel operations and layers,
    effects, subpixel imaging and antialiasing, and conversions, together
    with multilevel undo. The GIMP offers a scripting facility, but many
    of the included scripts rely on fonts that we cannot distribute.
Administrando os repositórios de software

O zypper também pode ser usado para gerenciar repositórios de software. Para ver uma lista de todos os repositórios atualmente registrados no seu sistema, use zypper repos:

# zypper repos
Repository priorities are without effect. All enabled repositories share the same priority.

#  | Alias                     | Name                               | Enabled | GPG Check | Refresh
---+---------------------------+------------------------------------+---------+-----------+--------
 1 | openSUSE-Leap-15.1-1      | openSUSE-Leap-15.1-1               | No      | ----      | ----
 2 | repo-debug                | Debug Repository                   | No      | ----      | ----
 3 | repo-debug-non-oss        | Debug Repository (Non-OSS)         | No      | ----      | ----
 4 | repo-debug-update         | Update Repository (Debug)          | No      | ----      | ----
 5 | repo-debug-update-non-oss | Update Repository (Debug, Non-OSS) | No      | ----      | ----
 6 | repo-non-oss              | Non-OSS Repository                 | Yes     | (r ) Yes  | Yes
 7 | repo-oss                  | Main Repository                    | Yes     | (r ) Yes  | Yes
 8 | repo-source               | Source Repository                  | No      | ----      | ----
 9 | repo-source-non-oss       | Source Repository (Non-OSS)        | No      | ----      | ----
10 | repo-update               | Main Update Repository             | Yes     | (r ) Yes  | Yes
11 | repo-update-non-oss       | Update Repository (Non-Oss)        | Yes     | (r ) Yes  | Yes
Na coluna Enabled vemos que alguns repositórios estão ativados e outros não. Para mudar isso, use o operador modifyrepo, seguido pelo parâmetro -e (enable) ou -d (disable) e pelo alias do repositório (a segunda coluna na saída acima).

# zypper modifyrepo -d repo-non-oss
Repository 'repo-non-oss' has been successfully disabled.

# zypper modifyrepo -e repo-non-oss
Repository 'repo-non-oss' has been successfully enabled.
Mencionamos anteriormente que o zypper possui um recurso de atualização automática que pode ser ativado caso a caso nos repositórios. Quando ativado, esse sinalizador faz com que o zypper execute uma operação de atualização (como se executássemos zypper refresh) antes de trabalhar com o repositório especificado. O processo pode ser controlado com os parâmetros -f e -F do operador modifyrepo:

# zypper modifyrepo -F repo-non-oss
Autorefresh has been disabled for repository 'repo-non-oss'.

# zypper modifyrepo -f repo-non-oss
Autorefresh has been enabled for repository 'repo-non-oss'.
Adicionando e removendo repositórios

Para adicionar um novo repositório de software para o zypper, use o operador addrepo seguido da URL e do nome do repositório, como abaixo:

# zypper addrepo http://packman.inode.at/suse/openSUSE_Leap_15.1/ packman
Adding repository 'packman' ........................................[done]
Repository 'packman' successfully added

URI         : http://packman.inode.at/suse/openSUSE_Leap_15.1/
Enabled     : Yes
GPG Check   : Yes
Autorefresh : No
Priority    : 99 (default priority)

Repository priorities are without effect. All enabled repositories share the same priority.
Ao adicionar um repositório, podemos ativar as atualizações automáticas com o parâmetro -f. Os repositórios adicionados são ativados por padrão, mas também é possível adicionar e desativar um repositório ao mesmo tempo usando o parâmetro -d. Para remover um repositório, use o operador removerepo seguido pelo nome do repositório (Alias). Para remover o repositório adicionado no exemplo acima, o comando seria:

# zypper removerepo packman
Removing repository 'packman' ......................................[done]
Repository 'packman' has been removed.


Respostas aos Exercícios Guiados
Usando o rpm em um sistema Red Hat Enterprise Linux, como você instalaria o pacote file-roller-3.28.1-2.el7.x86_64.rpm de maneira a exibir uma barra de progresso durante a instalação?

Use o parâmetro -i para instalar um pacote e a opção -h para habilitar os “sinais de hash” mostrando o progresso da instalação. Assim, a resposta é: rpm -ih file-roller-3.28.1-2.el7.x86_64.rpm.

Usando o rpm, descubra qual pacote contém o arquivo /etc/redhat-release.

Estamos solicitando informações sobre um arquivo, por isso usamos o parâmetro -qf: rpm -qf /etc/redhat-release.

Como você usaria o yum para procurar atualizações para todos os pacotes do sistema?

Use a operação check-update sem um nome de pacote: yum check-update.

Usando o zypper, como desabilitaríamos um repositório chamado repo-extras?

Use a operação modifyrepo para alterar os parâmetros de um repositório, e o parâmetro -d para desabilitá-lo: zypper modifyrepo -d repo-extras.

Se tivermos um arquivo .repo descrevendo um novo repositório, onde esse arquivo deve ser colocado para poder ser reconhecido pelo DNF?

Os arquivos .repo para o DNF devem ser postos no mesmo local usado pelo YUM, dentro de /etc/yum.repos.d/.

Respostas aos Exercícios Exploratórios
Como usar o zypper para descobrir qual pacote possui o arquivo /usr/sbin/swapon?

Use o operador se (search) e o parâmetro --provides: zypper se --provides /usr/sbin/swapon.

Como obter uma lista de todos os pacotes instalados no sistema usando o dnf?

Use o operador list, seguido pelo parâmetro --installed: dnf list --installed.

Usando o dnf, qual o comando para adicionar um repositório localizado em https://www.example.url/home:reponame.repo ao sistema?

O trabalho com repositórios é uma “mudança de configurações”, por isso use o config-manager e o parâmetro --add_repo: dnf config-manager --add_repo https://www.example.url/home:reponame.repo.

Como podemos usar o zypper para conferir se o pacote unzip está instalado?

Precisamos fazer uma busca (se) nos pacotes instalados (-i): zypper se -i unzip.

Usando o yum, descubra qual pacote fornece o arquivo /bin/wget.

Para descobrir quem fornece um arquivo, use whatprovides e o nome do arquivo: yum whatprovides /bin/wget.


Introdução
Um dos maiores pontos fortes do Linux é sua versatilidade. Um aspecto dessa versatilidade é a possibilidade de usar o Linux como meio de hospedar outros sistemas operacionais, ou aplicativos individuais, em um ambiente completamente isolado e seguro. Esta lição será dedicada aos conceitos de virtualização e tecnologias de contêiner, juntamente com alguns detalhes técnicos que devem ser levados em conta ao se implementar uma máquina virtual em uma plataforma de nuvem.

O que é virtualização?
A virtualização é uma tecnologia que permite que uma plataforma de software, chamada de hipervisor, execute processos que contêm um sistema inteiramente emulado (virtual). O hipervisor é responsável por gerenciar os recursos do hardware físico que podem ser usados por máquinas virtuais individuais. Essas máquinas virtuais são chamadas de guests (convidados) do hypervisor. Muitos dos aspectos de um computador físico são emulados por software na máquina virtual, como a BIOS do sistema e os controladores de disco rígido. Uma máquina virtual geralmente usa imagens de disco rígido que são armazenadas como arquivos individuais e tem acesso à RAM e à CPU da máquina hospedeira por meio do software hipervisor. O hipervisor divide o acesso aos recursos de hardware do sistema hospedeiro entre os convidados, permitindo assim que vários sistemas operacionais sejam executados em um único sistema hospedeiro.

Dentre os hipervisores mais comumente usados no Linux, podemos citar:

Xen
O Xen é um hipervisor de código aberto de Tipo 1, o que significa que ele não depende de um sistema operacional subjacente para funcionar. Um hipervisor desse tipo é conhecido como hipervisor bare-metal, pois o computador pode inicializar diretamente no hipervisor.

KVM
O Kernel Virtual Machine é um módulo de virtualização do kernel do Linux. O KVM é um hipervisor de Tipo 1 e também de Tipo 2 porque, embora precise de um sistema operacional Linux genérico para funcionar, é capaz de agir perfeitamente bem como hipervisor integrando-se a uma instalação Linux em execução. As máquinas virtuais implementadas com o KVM usam o daemon libvirt e utilitários de software associados para serem criadas e gerenciadas.

VirtualBox
Um aplicativo desktop popular que facilita a criação e o gerenciamento de máquinas virtuais. O Oracle VM VirtualBox é multiplataforma e funciona em Linux, macOS e Microsoft Windows. Como o VirtualBox requer um sistema operacional subjacente para ser executado, ele é um hipervisor de Tipo 2.

Alguns hipervisores permitem a realocação dinâmica de uma máquina virtual. O processo de mover uma máquina virtual de uma instalação do hipervisor para outra é chamado de migração e as técnicas envolvidas são diferentes conforme as implementações do hipervisor. Algumas migrações só podem ser realizadas quando o sistema convidado está completamente desligado e outras podem ser feitas com o convidado em execução (é o que chamamos migração ao vivo). Essas técnicas podem ser úteis durante a manutenção dos hipervisores, ou ainda para garantir a resiliência do sistema quando um hipervisor para de funcionar, sendo possível mover o convidado para outro.

Tipos de máquina virtual
Existem três tipos principais de máquinas virtuais, o convidado totalmente virtualizado, o convidado paravirtualizado e o convidado híbrido.

Totalmente virtualizado
Todas as instruções que um sistema operacional convidado precisa executar devem poder rodar em uma instalação de sistema operacional totalmente virtualizada. A razão para isso é que nenhum driver de software adicional é instalado na máquina virtual para traduzir as instruções para o hardware simulado ou real. O convidado totalmente virtualizado (ou HardwareVM) não sabe que é uma instância de máquina virtual em execução. Para que esse tipo de virtualização seja possível com hardware baseado em x86, as extensões de CPU Intel VT-x ou AMD-V devem ser habilitadas no sistema no qual o hipervisor está instalado. Isso pode ser feito a partir de um menu de configuração de firmware na BIOS ou UEFI.

Paravirtualizado
Um convidado paravirtualizado (ou PVM) é aquele que está ciente de ser uma instância de máquina virtual em execução. Esses tipos de convidados fazem uso de um kernel modificado e drivers especiais (conhecidos como drivers convidados) que ajudam o sistema operacional convidado a utilizar os recursos de software e hardware do hipervisor. O desempenho de um convidado paravirtualizado costuma ser melhor do que o de um convidado totalmente virtualizado devido à vantagem oferecida por esses drivers de software.

Híbrido
A paravirtualização e a virtualização total podem ser combinadas para permitir que sistemas operacionais não modificados tenham um desempenho de E/S quase nativo usando drivers paravirtualizados em sistemas operacionais totalmente virtualizados. Os drivers paravirtualizados contêm drivers de dispositivos de armazenamento e de rede com desempenho aprimorado de E/S de disco e de rede.

As plataformas de virtualização geralmente fornecem drivers convidados para os sistemas operacionais virtualizados. O KVM utiliza drivers do projeto Virtio, enquanto o Oracle VM VirtualBox usa Extensões de Convidado disponíveis em um arquivo de imagem ISO de CD-ROM para download.

Exemplo de máquina virtual libvirt
Veremos um exemplo de máquina virtual que é gerenciada por libvirt e usa o hipervisor KVM. Uma máquina virtual geralmente consiste em um grupo de arquivos, principalmente um arquivo XML que define a máquina virtual (sua configuração de hardware, conectividade de rede, recursos de exibição etc.) e um arquivo de imagem de disco rígido associado contendo a instalação do sistema operacional e seu software.

Primeiro, vamos examinar um exemplo de arquivo de configuração XML para uma máquina virtual e seu ambiente de rede:

$ ls /etc/libvirt/qemu
total 24
drwxr-xr-x 3 root root 4096 Oct 29 17:48 networks
-rw------- 1 root root 5667 Jun 29 17:17 rhel8.0.xml
Note
A parte qemu do caminho do diretório se refere ao software subjacente do qual dependem as máquinas virtuais baseadas em KVM. O projeto QEMU fornece software para o hipervisor para emular os dispositivos de hardware que serão usados pela máquina virtual, como controladores de disco, acesso à CPU do host, emulação de placa de rede e muito mais.

Observe que existe um diretório chamado networks. Esse diretório contém arquivos de definição (que também usam XML) que criam configurações de rede utilizáveis pelas máquinas virtuais. Este hipervisor está usando apenas uma rede e, portanto, há apenas um arquivo de definição contendo uma configuração para um segmento de rede virtual que será usado por esses sistemas.

$ ls -l /etc/libvirt/qemu/networks/
total 8
drwxr-xr-x 2 root root 4096 Jun 29 17:15 autostart
-rw------- 1 root root  576 Jun 28 16:39 default.xml
$ sudo cat /etc/libvirt/qemu/networks/default.xml
<!--
WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE
OVERWRITTEN AND LOST. Changes to this xml configuration should be made using:
  virsh net-edit default
or other application using the libvirt API.
-->

<network>
  <name>default</name>
  <uuid>55ab064f-62f8-49d3-8d25-8ef36a524344</uuid>
  <forward mode='nat'/>
  <bridge name='virbr0' stp='on' delay='0'/>
  <mac address='52:54:00:b8:e0:15'/>
  <ip address='192.168.122.1' netmask='255.255.255.0'>
    <dhcp>
      <range start='192.168.122.2' end='192.168.122.254'/>
    </dhcp>
  </ip>
</network>
Esta definição inclui uma rede privada Classe C e um dispositivo de hardware emulado que age como um roteador para esta rede. Também vemos um intervalo de endereços IP que o hipervisor, junto com com uma implementação de servidor DHCP, pode atribuir às máquinas virtuais que usam esta rede. Essa configuração de rede também utiliza a tradução de endereços de rede (NAT) para encaminhar pacotes para outras redes, como a LAN do hipervisor.

Veremos a seguir um arquivo de definição de máquina virtual Red Hat Enterprise Linux 8 (as seções mais importantes estão em negrito):

$ sudo cat /etc/libvirt/qemu/rhel8.0.xml
<!--
WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE
OVERWRITTEN AND LOST. Changes to this xml configuration should be made using:
  virsh edit rhel8.0
or other application using the libvirt API.
-->

<domain type='kvm'>
  <name>rhel8.0</name>
  <uuid>fadd8c5d-c5e1-410e-b425-30da7598d0f6</uuid>
  <metadata>
    <libosinfo:libosinfo xmlns:libosinfo="http://libosinfo.org/xmlns/libvirt/domain/1.0">
      <libosinfo:os id="http://redhat.com/rhel/8.0"/>
    </libosinfo:libosinfo>
  </metadata>
  <memory unit='KiB'>4194304</memory>
  <currentMemory unit='KiB'>4194304</currentMemory>
  <vcpu placement='static'>2</vcpu>
  <os>
    <type arch='x86_64' machine='pc-q35-3.1'>hvm</type>
    <boot dev='hd'/>
  </os>
  <features>
    <acpi/>
    <apic/>
    <vmport state='off'/>
  </features>
  <cpu mode='host-model' check='partial'>
    <model fallback='allow'/>
  </cpu>
  <clock offset='utc'>
    <timer name='rtc' tickpolicy='catchup'/>
    <timer name='pit' tickpolicy='delay'/>
    <timer name='hpet' present='no'/>
  </clock>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>destroy</on_crash>
  <pm>
    <suspend-to-mem enabled='no'/>
    <suspend-to-disk enabled='no'/>
  </pm>
  <devices>
    <emulator>/usr/bin/qemu-system-x86_64</emulator>
    <disk type='file' device='disk'>
      <driver name='qemu' type='qcow2'/>
      <source file='/var/lib/libvirt/images/rhel8'/>
      <target dev='vda' bus='virtio'/>
      <address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/>
    </disk>
    <controller type='usb' index='0' model='qemu-xhci' ports='15'>
      <address type='pci' domain='0x0000' bus='0x02' slot='0x00' function='0x0'/>
    </controller>
    <controller type='sata' index='0'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x1f' function='0x2'/>
    </controller>
    <controller type='pci' index='0' model='pcie-root'/>
    <controller type='pci' index='1' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='1' port='0x10'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0' multifunction='on'/>
    </controller>
    <controller type='pci' index='2' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='2' port='0x11'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x1'/>
    </controller>
    <controller type='pci' index='3' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='3' port='0x12'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x2'/>
    </controller>
    <controller type='pci' index='4' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='4' port='0x13'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x3'/>
    </controller>
    <controller type='pci' index='5' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='5' port='0x14'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x4'/>
    </controller>
    <controller type='pci' index='6' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='6' port='0x15'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x5'/>
    </controller>
    <controller type='pci' index='7' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='7' port='0x16'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x6'/>
    </controller>
    <controller type='virtio-serial' index='0'>
      <address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>
    </controller>
    <interface type='network'>
      <mac address='52:54:00:50:a7:18'/>
      <source network='default'/>
      <model type='virtio'/>
      <address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>
    </interface>
    <serial type='pty'>
      <target type='isa-serial' port='0'>
        <model name='isa-serial'/>
      </target>
    </serial>
    <console type='pty'>
      <target type='serial' port='0'/>
    </console>
    <channel type='unix'>
      <target type='virtio' name='org.qemu.guest_agent.0'/>
      <address type='virtio-serial' controller='0' bus='0' port='1'/>
    </channel>
    <channel type='spicevmc'>
      <target type='virtio' name='com.redhat.spice.0'/>
      <address type='virtio-serial' controller='0' bus='0' port='2'/>
    </channel>
    <input type='tablet' bus='usb'>
      <address type='usb' bus='0' port='1'/>
    </input>
    <input type='mouse' bus='ps2'/>
    <input type='keyboard' bus='ps2'/>
    <graphics type='spice' autoport='yes'>
      <listen type='address'/>
      <image compression='off'/>
    </graphics>
    <sound model='ich9'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x1b' function='0x0'/>
    </sound>
    <video>
      <model type='virtio' heads='1' primary='yes'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x0'/>
    </video>
    <redirdev bus='usb' type='spicevmc'>
      <address type='usb' bus='0' port='2'/>
    </redirdev>
    <redirdev bus='usb' type='spicevmc'>
      <address type='usb' bus='0' port='3'/>
    </redirdev>
    <memballoon model='virtio'>
      <address type='pci' domain='0x0000' bus='0x05' slot='0x00' function='0x0'/>
    </memballoon>
    <rng model='virtio'>
      <backend model='random'>/dev/urandom</backend>
      <address type='pci' domain='0x0000' bus='0x06' slot='0x00' function='0x0'/>
    </rng>
  </devices>
</domain>
Este arquivo define uma série de configurações de hardware que são usadas por este convidado, como a quantidade de RAM que lhe será atribuída, o número de núcleos da CPU do hipervisor a que o convidado terá acesso, o arquivo de imagem de disco rígido associado a este convidado (na estrofe disk), seus recursos de exibição (por meio do protocolo SPICE) e o acesso do convidado a dispositivos USB, bem como o teclado emulado e a entrada de mouse.

Exemplo de armazenamento em disco de uma máquina virtual
A imagem de disco rígido desta máquina virtual reside em /var/lib/libvirt/images/rhel8. Eis a imagem de disco em si neste hipervisor:

$ sudo ls -lh /var/lib/libvirt/images/rhel8
-rw------- 1 root root 5.5G Oct 25 15:57 /var/lib/libvirt/images/rhel8
O tamanho atual desta imagem de disco consome apenas 5,5 GB de espaço no hipervisor. No entanto, o sistema operacional deste convidado vê um disco de 23,3 GB, conforme evidenciado pela saída do seguinte comando lançado dentro da máquina virtual em execução:

$ lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
vda           252:0    0 23.3G  0 disk
├─vda1        252:1    0    1G  0 part /boot
└─vda2        252:2    0 22.3G  0 part
  ├─rhel-root 253:0    0   20G  0 lvm  /
  └─rhel-swap 253:1    0  2.3G  0 lvm  [SWAP]
Isso se deve ao tipo de provisionamento de disco usado para este convidado. Existem vários tipos de imagens de disco que uma máquina virtual pode usar, mas os dois principais são:

COW
Copy-on-write ou cópia na gravação (também conhecida como thin-provisioning ou sparse images) é um método em que um arquivo de disco é criado com um limite máximo de tamanho predefinido. O tamanho da imagem do disco só aumenta quando novos dados são gravados no disco. Como no exemplo anterior, o sistema operacional convidado vê o limite de disco predefinido de 23,3 GB, mas gravou apenas 5,5 GB de dados no arquivo de disco. O formato de imagem de disco usado para a máquina virtual de exemplo é qcow2, um formato de arquivo QEMU COW.

RAW
Um tipo de disco raw ou full é um arquivo que tem todo o seu espaço pré-alocado. Por exemplo, um arquivo de imagem de disco raw de 10 GB consome 10 GB de espaço em disco real no hipervisor. Esse estilo de disco permite um ganho de desempenho, pois todo o espaço em disco necessário já existe, de modo que o hipervisor subjacente pode simplesmente gravar dados no disco sem o impacto no desempenho que seria causado pela necessidade de monitorar a imagem do disco para garantir que ele não atingiu seu limite e de estender o tamanho do arquivo à medida que novos dados são gravados nele.

Existem outras plataformas de gerenciamento de virtualização, como o Red Hat Enterprise Virtualization e o oVirt, que podem lançar mão de discos físicos como locais de armazenamento secundários para o sistema operacional de uma máquina virtual. Esses sistemas utilizam dispositivos de rede de área de armazenamento (SAN) ou de armazenamento conectado à rede (NAS) para gravar seus dados, e o hipervisor controla quais locais de armazenamento pertencem a quais máquinas virtuais. Esses sistemas de armazenamento podem usar tecnologias como o gerenciamento de volume lógico (LVM) para aumentar ou diminuir o tamanho do armazenamento em disco de uma máquina virtual conforme necessário e para auxiliar na criação e gerenciamento de instantâneos de armazenamento.

Trabalhando com modelos de máquina virtual
Como as máquinas virtuais são, tipicamente, apenas arquivos em execução em um hipervisor, é fácil criar modelos que podem ser personalizados para cenários específicos de implantação. Freqüentemente, uma máquina virtual contém uma instalação básica de sistema operacional e algumas configurações de autenticação predefinidas para facilitar futuras inicializações do sistema. Isso diminui o tempo necessário para construir um novo sistema, reduzindo a quantidade de trabalho repetitivo, como a instalação de pacotes básicos e as configurações de localidade.

Esse modelo de máquina virtual pode ser copiado posteriormente para um novo sistema convidado. Nesse caso, o novo convidado receberia um novo nome e um novo endereço MAC para sua interface de rede, além de outras modificações dependendo do uso pretendido.

O D-Bus Machine ID
Muitas instalações do Linux utilizam um número de identificação de máquina gerado no momento da instalação, chamado de D-Bus machine ID. No entanto, se uma máquina virtual for clonada para ser usada como modelo para outras instalações de máquina virtual, um novo D-Bus machine ID precisará ser criado para garantir que os recursos do sistema do hipervisor sejam direcionados ao sistema convidado correto.

O comando a seguir serve para validar se existe um D-Bus machine ID para o sistema em execução:

$ dbus-uuidgen --ensure
Se nenhuma mensagem de erro for exibida, é porque já existe um ID para o sistema. Para visualizar o D-Bus machine ID atual, execute o seguinte:

$ dbus-uuidgen --get
17f2e0698e844e31b12ccd3f9aa4d94a
A sequência de caracteres exibida é o número de ID atual. Dois sistemas Linux em execução em um hipervisor não devem ter o mesmo D-Bus machine ID.

O D-Bus machine ID localiza-se em /var/lib/dbus/machine-id e está simbolicamente ligado a /etc/machine-id. Não é recomendável alterar esse número de ID em um sistema em execução, pois isso pode acarretar instabilidades e travamentos do sistema. Se duas máquinas virtuais tiverem o mesmo D-Bus machine ID, siga o procedimento abaixo para gerar um novo:

$ sudo rm -f /etc/machine-id
$ sudo dbus-uuidgen --ensure=/etc/machine-id
Se por acaso /var/lib/dbus/machine-id não for um link simbólico que remete a /etc/machine-id, /var/lib/dbus/machine-id terá de ser removido.

Implementação de máquinas virtuais na nuvem
Muitos provedores de IaaS (infraestrutura como serviço) executam sistemas de hipervisor e podem implantar imagens de máquinas virtuais para uma empresa. Praticamente todos esses provedores oferecem ferramentas que permitem a um administrador construir, implementar e configurar máquinas virtuais personalizadas com base em uma variedade de distribuições Linux. Muitos deles também possuem sistemas que permitem a implementação e migração de máquinas virtuais construídas de dentro da empresa de um cliente.

Ao avaliar a implementação de um sistema Linux em um ambiente IaaS, existem alguns elementos-chave que um administrador deve conhecer:

Instâncias de computação
Muitos provedores de nuvem cobram taxas de uso com base em “instâncias de computação”, ou o tempo de CPU que será usado por uma infraestrutura baseada em nuvem. O planejamento cuidadoso do tempo de processamento real exigido por cada aplicativo ajuda a manter gerenciáveis os custos de uma solução em nuvem.

As instâncias de computação também se referem ao número de máquinas virtuais provisionadas em um ambiente de nuvem. Também neste caso o maior número de instâncias de sistemas em execução ao mesmo tempo influencia no tempo geral de CPU que uma empresa terá de pagar.

Armazenamento em bloco
Os provedores de nuvem também oferecem diversos níveis de armazenamento em bloco para uso empresarial. Algumas ofertas consistem simplesmente em armazenamento de rede baseado na web para arquivos; outras oferecem armazenamento externo para uma máquina virtual provisionada em nuvem e usada para hospedar arquivos.

O custo dessas ofertas varia de acordo com a quantidade de armazenamento usada e a velocidade do armazenamento nos data centers do provedor. Um acesso mais rápido ao armazenamento normalmente custa mais e, inversamente, os dados "em repouso" (como no caso do arquivamento de dados) costumam ser bem baratos.

Rede
Um dos principais componentes do trabalho com um provedor de soluções em nuvem é a maneira como a rede virtual será configurada. Muitos provedores de IaaS oferecem alguma forma de utilitários baseados na web que podem ser utilizados para o projeto e implementação de diferentes rotas de rede, sub-redes e configurações de firewall. Alguns fornecem até mesmo soluções de DNS para ser possível atribuir FQDN (nomes de domínio absolutos) publicamente acessíveis aos sistemas de Internet do cliente. Existem também soluções “híbridas” capazes de conectar uma infraestrutura de rede local existente a uma infraestrutura baseada em nuvem por meio de uma VPN (rede privada virtual), unindo assim as duas infraestruturas

Acessando convidados na nuvem com segurança
O método mais comum para acessar uma máquina virtual remota em uma plataforma de nuvem é por meio do software OpenSSH. Um sistema Linux residente na nuvem teria o servidor OpenSSH em execução, enquanto um administrador usaria um cliente OpenSSH com chaves pré-compartilhadas para acesso remoto.

Um administrador executaria o seguinte comando:

$ ssh-keygen
seguindo as instruções para criar um par de chaves SSH públicas e privadas. A chave privada permanece no sistema local do administrador (armazenada em ~/.ssh/) e a chave pública é copiada para o sistema de nuvem remoto, exatamente o mesmo método que se usaria ao trabalhar com máquinas em rede em uma LAN corporativa.

O administrador então executaria o seguinte comando:

$ ssh-copy-id -i <public_key> user@cloud_server
Ele copia a chave SSH pública do par que acaba de ser gerado para o servidor de nuvem remoto. A chave pública é gravada no arquivo ~/.ssh/authorized_keys do servidor na nuvem e define as permissões apropriadas no arquivo.

Note
Se houver apenas um arquivo de chave pública no diretório ~/.ssh/, então a opção -i pode ser omitida, pois o comando ssh-copy-id será o padrão para o arquivo de chave pública no diretório (normalmente o arquivo que termina com a extensão .pub).

Alguns provedores de nuvem geram automaticamente um par de chaves quando um novo sistema Linux é provisionado. O administrador precisa então baixar a chave pública para o novo sistema do provedor de nuvem e armazená-la em seu sistema local. Observe que as permissões para chaves SSH devem ser 0600 para uma chave privada e 0644 para uma chave pública.

Pré-configurando sistemas em nuvem
Uma ferramenta útil que simplifica as implementações de máquina virtual baseada em nuvem é o utilitário cloud-init. Esse comando, junto com os arquivos de configuração associados e a imagem de máquina virtual predefinida, é um método neutro (independente de fornecedor) para implementar um convidado Linux em uma infinidade de provedores de IaaS. Utilizando arquivos de texto simples YAML (YAML Ain’t Markup Language), o administrador pode pré-configurar as definições de rede, a seleção de pacotes de software, a configuração de chave SSH, a criação de contas de usuário e as configurações de localidade, além de uma série de outras opções para criar novos sistemas rapidamente.

Durante a inicialização de um novo sistema, o cloud-init lê as definições dos arquivos de configuração YAML e as aplica. Basta efetuar esse processo na configuração inicial de um sistema e a implantação de uma frota de novos sistemas em uma plataforma de provedor de nuvem ficará muito mais fácil.

A sintaxe do arquivo YAML usado com cloud-init se chama cloud-config. Eis um exemplo de arquivo cloud-config:

#cloud-config
timezone: Africa/Dar_es_Salaam
hostname: test-system

# Update the system when it first boots up
apt_update: true
apt_upgrade: true

# Install the Nginx web server
packages:
 - nginx
Observe que na linha superior não há espaço entre o símbolo hash (#) e o termo cloud-config.

Note
cloud-init não é apenas para máquinas virtuais. O conjunto de ferramentas cloud-init também pode ser usado para pré-configurar contêineres (como contêineres LXD Linux) antes da implementação.

Contêiners
A tecnologia de contêiner lembra uma máquina virtual em certos aspectos: eles proporcionam um ambiente isolado para implementar facilmente um aplicativo. Ao passo que, com uma máquina virtual, um computador inteiro é emulado, um contêiner usa apenas o software suficiente para executar um aplicativo. Dessa forma, há muito menos sobrecarga.

Os contêineres permitem uma maior flexibilidade em relação a uma máquina virtual. Um contêiner de aplicativo pode ser migrado de um hospedeiro para outro, assim como uma máquina virtual pode ser migrada de um hipervisor para outro. No entanto, às vezes, uma máquina virtual precisa ser desligada antes de poder ser migrada, enquanto no contêiner o aplicativo permanece em execução enquanto está sendo migrado. Os contêineres também facilitam a implementação de novas versões de aplicativos em conjunto com uma versão existente. Conforme os usuários fecham suas sessões com contêineres em execução, esses contêineres podem ser removidos automaticamente do sistema pelo software de orquestração de contêineres e substituídos pela nova versão, reduzindo assim o tempo de inatividade.

Note
Existem várias tecnologias de contêiner disponíveis para Linux, como Docker, Kubernetes, LXD / LXC, systemd-nspawn, OpenShift e outros. A implementação exata de um pacote de software contêiner está além do escopo do exame LPIC-1.

Os contêineres usam o mecanismo de grupos de controle (mais conhecido como cgroups) no kernel do Linux. O cgroup é uma forma de particionar os recursos do sistema, como memória, tempo do processador, bem como disco e largura de banda da rede, para um aplicativo individual. Um administrador pode usar cgroups diretamente para definir os limites de recursos do sistema em um aplicativo ou um grupo de aplicativos existentes em um único cgroup. Em essência, é isso o que o software de contêiner faz para o administrador, além de fornecer ferramentas que facilitam o gerenciamento e a implementação de cgroups.

Note
Atualmente, o conhecimento de cgroups não é necessário para prestar o exame LPIC-1. O conceito de cgroup é mencionado aqui para que o candidato tenha pelo menos algum conhecimento prévio de como um aplicativo é segregado para fins de utilização dos recursos do sistema.


Respostas aos Exercícios Guiados
Quais extensões de CPU são necessárias em uma plataforma de hardware baseada em x86 para rodar convidados totalmente virtualizados?

VT-x para as CPUs Intel ou AMD-V para CPUs AMD

Uma instalação de servidor de missão crítica, que exige um desempenho mais rápido, provavelmente usará que tipo de virtualização?

Um sistema operacional que faz uso de paravirtualização, como o Xen, pois o sistema operacional convidado poderá fazer melhor uso dos recursos de hardware disponíveis com drivers de software projetados para funcionar com o hipervisor.

Duas máquinas virtuais que foram clonadas a partir do mesmo modelo e que utilizam o D-Bus apresentam desempenho irregular. Ambas têm nomes de host e definições de configuração de rede separadas. Qual comando seria usado para determinar se cada uma das máquinas virtuais tem diferentes D-Bus Machine IDs?

dbus-uuidgen --get

Respostas aos Exercícios Exploratórios

Execute o seguinte comando para ver se seu sistema já tem extensões de CPU habilitadas para rodar uma máquina virtual (os resultados podem variar dependendo de sua CPU): 
grep --color -E "vmx|svm" /proc/cpuinfo. Dependendo da saída, vmx pode estar realçado (para CPUs habilitadas com Intel VT-x) ou, ainda, svm (para CPUs habilitadas com AMD SVM). Se não obtiver resultados, consulte as instruções da BIOS ou da UEFI sobre como habilitar a virtualização para o seu processador.

Os resultados variam dependendo da sua CPU. Eis um exemplo de saída de um computador com uma CPU Intel com extensões de virtualização habilitadas no firmware UEFI:

$ grep --color -E "vmx|svm" /proc/cpuinfo
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single pti ssbd ibrs ibpb stibp tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d
Se o seu processador suporta virtualizações, procure a documentação da sua distribuição para executar um hipervisor KVM.

Instale os pacotes necessários para executar um hipervisor KVM.

O método vai variar de acordo com a distribuição, mas aqui estão alguns pontos de partida:

Ubuntu — https://help.ubuntu.com/lts/serverguide/libvirt.html

Fedora — https://docs.fedoraproject.org/en-US/quick-docs/getting-started-with-virtualization/

Arch Linux — https://wiki.archlinux.org/index.php/KVM

Se estiver usando um ambiente de desktop gráfico, é recomendado instalar também o aplicativo virt-manager, um front-end gráfico que pode ser usado em uma instalação KVM. Isso ajudará na instalação e gerenciamento da máquina virtual.

Mais uma vez, o método vai depender da distribuição. Eis um exemplo usando o Ubuntu:

$ sudo apt install virt-manager
Baixe a imagem ISO de uma distribuição Linux à sua escolha e, seguindo a documentação da distribuição, crie uma nova máquina virtual usando essa ISO.

O pacote virt-manager facilita muito essa tarefa. No entanto, uma máquina virtual pode ser criada a partir da linha de comando usando o comando virt-install. Experimente os dois métodos para entender como as máquinas virtuais são implementadas.
